{
    "id": "v1-M-1",
    "instruction": "Design a PLC program using structured text (ST code) that incorporates pressure sensors,\ntemperature sensors, relays, counters, error codes, and error flags as inputs.\nThe program must loop through the pressure sensor, adjust the temperature sensor\nbased on specific conditions, and update the relay status according to the value of GT1_OUT.\nEnsure that the program checks for conditions to avoid overflow and maintains the error flag state.\nReturn a Boolean value indicating the completion of the operation.\n\nPROGRAM MAIN\nVAR\npresure_sensor : UINT := 10;\ntemp_sensor : INT := 2;\nrelay : BOOL := TRUE;\ncounter : UINT;\nerror_code : INT;\nerror : BOOL := TRUE;\nGT1_OUT : BOOL;\nEND_VAR\n\nEND_PROGRAM",
    "properties_to_be_validated": [
        {
            "property_description": "Verify that all assertions are satisfied in the program.",
            "property": {
                "job_req": "assertion"
            }
        },
        {
            "property_description": "Verify that the relay is updated based on the value of GT1_OUT.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.GT1_OUT = TRUE",
                    "2": "instance.relay = TRUE"
                },
                "pattern_description": "If 'instance.GT1_OUT = TRUE' is true at the end of the PLC cycle, then 'instance.relay = TRUE' should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Verify that the temp_sensor does not overflow during the FOR loop.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-forbidden",
                "pattern_params": {
                    "1": "instance.temp_sensor > 32767"
                },
                "pattern_description": "'instance.temp_sensor > 32767' is impossible at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Verify that the error flag is not set to FALSE.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-forbidden",
                "pattern_params": {
                    "1": "instance.error = FALSE"
                },
                "pattern_description": "'instance.error = FALSE' is impossible at the end of the PLC cycle."
            }
        }
    ]
}
{
    "id": "v1-M-2",
    "instruction": "Design a PLC program using structured text (ST code) that includes a function block named `F_CollectInput` and a main program named `MAIN`.\n\nThe main program begins by invoking the `CollectInput` function block to gather input signals (`IN1`, `IN2`, `IN3`, `IN4`, and `IN5`) into a Boolean array called `Data`. Once data collection is complete, indicated by the `Finished` flag from the function block, the program sets a `Ready` flag to signal readiness for further processing.\n\nUpon readiness, the program calculates an output signal `Out` based on complex logical conditions:\nNOT (A1 OR A2 OR A3 OR ... OR A15)  , where the A1 to A15 satisfy:\n\n```plain\nA1 = NOT (Data[7]) AND NOT (Data[3]) AND NOT (Data[2]) AND NOT (Data[1]) OR Data[5];\nA2 = Data[7] AND NOT (Data[3]) AND NOT (Data[2]) AND NOT (Data[1]) OR Data[6];\nA3 = NOT (Data[7]) AND Data[3] AND NOT (Data[2]) AND NOT (Data[1]) OR Data[12];\nA4 = Data[7] AND Data[3] AND NOT (Data[2]) AND NOT (Data[1]) OR Data[8];\nA5 = NOT (Data[7]) AND NOT (Data[3]) AND Data[2] AND NOT (Data[1]) OR Data[4];\nA6 = Data[7] AND NOT (Data[3]) AND Data[2] AND NOT (Data[1]) OR Data[9];\nA7 = NOT (Data[7]) AND Data[3] AND Data[2] AND NOT (Data[1]) OR Data[10];\nA8 = Data[7] AND Data[3] AND Data[2] AND NOT (Data[1]) OR Data[16];\nA9 = NOT (Data[7]) AND NOT (Data[3]) AND NOT (Data[2]) AND Data[1] OR Data[11];\nA10 = Data[7] AND NOT (Data[3]) AND NOT (Data[2]) AND Data[1] OR Data[14];\nA11 = NOT (Data[7]) AND Data[3] AND NOT (Data[2]) AND Data[1] OR Data[17];\nA12 = Data[7] AND Data[3] AND NOT (Data[2]) AND Data[1] OR Data[18];\nA13 = NOT (Data[7]) AND NOT (Data[3]) AND Data[2] AND Data[1] OR Data[13];\nA14 = Data[7] AND NOT (Data[3]) AND Data[2] AND Data[1] OR Data[20];\nA15 = NOT (Data[7]) AND Data[3] AND Data[2] AND Data[1] OR Data[15];\n```\n\nSystem evaluate the values stored in the `Data` array.\nThen the output readiness flag `OutReady` is set to true, indicating that the system is prepared to produce the final output.\n\nFinally, after the output is calculated, the program resets the `CollectInput` function block to prepare for the next\nround of data collection by setting the `RESET` flag to true.\n\nThe program includes a function block named `F_CollectInput`,\nwhich collects multiple input signals (`IN1`, `IN2`, `IN3`, `IN4`, and `IN5`)\ninto a Boolean array called `Data` during each cycle when triggered by a clock signal `TICK`.\nThe data collection occurs only when the `RESET` signal is not activated,\nensuring that the system captures inputs correctly.\n\nWhen the system captures data, it stores the input values in `Data`,\nupdates the index for future data collection,\nand sets the `Finished` output flag to indicate when the data array is fully populated (after 20 inputs).\nIf a reset is initiated, the index is reset, and the previous data collection is cleared,\nreadying the system for a new set of inputs.\n\n\nFUNCTION_BLOCK F_CollectInput\nVAR_IN_OUT\nData : ARRAY[1 .. 20] OF BOOL;\nEND_VAR\nVAR_INPUT\nTICK  : BOOL := 0;\nIN1   : BOOL := 0;\nIN2   : BOOL := 0;\nIN3   : BOOL := 0;\nIN4   : BOOL := 0;\nIN5   : BOOL := 0;\nRESET : BOOL := FALSE;\nEND_VAR\nVAR_OUTPUT\nFinished : BOOL;\nEND_VAR\nVAR\nj    : USINT := 1;\ntock : BOOL  := 0;\nEND_VAR\n\nEND_FUNCTION_BLOCK\n\nPROGRAM MAIN\nVAR\nData  : ARRAY[1 .. 20] OF BOOL;\nReady : BOOL;\nCollectInput : F_CollectInput;\nEND_VAR\nVAR\nTICK     : BOOL;\nIN1      : BOOL;\nIN2      : BOOL;\nIN3      : BOOL;\nIN4      : BOOL;\nIN5      : BOOL;\nOutReady : BOOL := FALSE;\nFeedNext : BOOL := FALSE;\nOut      : BOOL;\nEND_VAR\n\nEND_PROGRAM",
    "properties_to_be_validated": [
        {
            "property_description": "Verify that all assertions are satisfied in the program.",
            "property": {
                "job_req": "assertion"
            }
        },
        {
            "property_description": "Verify that the Data array is not accessed out of bounds.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.j >= 1 AND instance.j <= 20"
                },
                "pattern_description": "'instance.j >= 1 AND instance.j <= 20' is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Verify that the Finished flag is set correctly when the Data array is fully populated.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.Finished = (instance.j > 20)"
                },
                "pattern_description": "'instance.Finished = (instance.j > 20)' is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Verify that the Out flag is computed correctly based on the logical conditions specified.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.Out = (((((((((((((((((NOT ((((NOT instance.Data[7]) AND (NOT instance.Data[3])) AND (NOT instance.Data[2])) AND (NOT instance.Data[1]))) OR instance.Data[5]) AND ((NOT (((instance.Data[7] AND (NOT instance.Data[3])) AND (NOT instance.Data[2])) AND (NOT instance.Data[1]))) OR instance.Data[6])) AND ((NOT ((((NOT instance.Data[7]) AND instance.Data[3]) AND (NOT instance.Data[2])) AND (NOT instance.Data[1]))) OR instance.Data[12])) AND ((NOT (((instance.Data[7] AND instance.Data[3]) AND (NOT instance.Data[2])) AND (NOT instance.Data[1]))) OR instance.Data[8])) AND ((NOT ((((NOT instance.Data[7]) AND (NOT instance.Data[3])) AND instance.Data[2]) AND (NOT instance.Data[1]))) OR instance.Data[4])) AND ((NOT (((instance.Data[7] AND (NOT instance.Data[3])) AND instance.Data[2]) AND (NOT instance.Data[1]))) OR instance.Data[9])) AND ((NOT ((((NOT instance.Data[7]) AND instance.Data[3]) AND instance.Data[2]) AND (NOT instance.Data[1]))) OR instance.Data[10])) AND ((NOT (((instance.Data[7] AND instance.Data[3]) AND instance.Data[2]) AND (NOT instance.Data[1]))) OR instance.Data[16])) AND ((NOT ((((NOT instance.Data[7]) AND (NOT instance.Data[3])) AND (NOT instance.Data[2])) AND instance.Data[1])) OR instance.Data[11])) AND ((NOT (((instance.Data[7] AND (NOT instance.Data[3])) AND (NOT instance.Data[2])) AND instance.Data[1])) OR instance.Data[14])) AND ((NOT ((((NOT instance.Data[7]) AND instance.Data[3]) AND (NOT instance.Data[2])) AND instance.Data[1])) OR instance.Data[17])) AND ((NOT (((instance.Data[7] AND instance.Data[3]) AND (NOT instance.Data[2])) AND instance.Data[1])) OR instance.Data[18])) AND ((NOT ((((NOT instance.Data[7]) AND (NOT instance.Data[3])) AND instance.Data[2]) AND instance.Data[1])) OR instance.Data[13])) AND ((NOT (((instance.Data[7] AND (NOT instance.Data[3])) AND instance.Data[2]) AND instance.Data[1])) OR instance.Data[20])) AND ((NOT ((((NOT instance.Data[7]) AND instance.Data[3]) AND instance.Data[2]) AND instance.Data[1])) OR instance.Data[15])) AND ((NOT (((instance.Data[7] AND instance.Data[3]) AND instance.Data[2]) AND instance.Data[1])) OR instance.Data[19]));"
                },
                "pattern_description": "{1} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Verify that the OutReady flag is set to TRUE when the output processing is complete.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.OutReady = (instance.Ready AND instance.Out)"
                },
                "pattern_description": "'instance.OutReady = (instance.Ready AND instance.Out)' is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Verify that the RESET functionality works correctly and resets the state of the F_CollectInput function block.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.RESET = TRUE --> instance.j = 1 AND instance.tock = 0"
                },
                "pattern_description": "'instance.RESET = TRUE --> instance.j = 1 AND instance.tock = 0' is always true at the end of the PLC cycle."
            }
        }
    ]
}
{
    "id": "v1-M-3",
    "instruction": "Instruction: \"Use Structured Text (ST) to design a Function Block (FB) that takes multiple integer inputs and performs a series of conditional operations to determine the maximum and minimum values among them. The Function Block should:\n\nInputs:\n\nAccept five integer inputs (input1, input2, input3, input4, input5).\nTrack the number of executions using a cycle counter (CYCLE), which will be incremented by 1 each time the Function Block is executed.\nIntermediate Calculations:\n\nYou should first realize  USER_MAX Function Block to determine intermediate maximum values,\nand a USER_MIN Function Block to determine intermediate minimum values.\nDetailed Calculation Process:\n\nStep 1: Calculate the intermediate maximum value (TEMP_MAX_OUT):\nUse USER_MAX to compare input2 and input3.\nSet TEMP_MAX_OUT to the larger of input2 and input3.\nStep 2: Calculate M as the maximum value between input1 and TEMP_MAX_OUT:\nUse USER_MAX to compare input1 with TEMP_MAX_OUT.\nAssign the larger value to M.\nStep 3: Calculate the intermediate minimum value (TEMP_MIN_2_OUT):\nUse USER_MIN to compare input4 and input5.\nSet TEMP_MIN_2_OUT to the smaller of input4 and input5.\nStep 4: Calculate another intermediate value (TEMP_MIN_3_OUT) using a more complex expression:\nUse USER_MIN to compare input2 and (input3 * TEMP_MIN_2_OUT + input2).\nThe multiplication and addition should be computed first: Multiply input3 by TEMP_MIN_2_OUT and then add input2.\nUse USER_MIN to find the smaller value between input2 and the result of the calculation (input3 * TEMP_MIN_2_OUT + input2).\nSet TEMP_MIN_3_OUT to this smaller value.\nStep 5: Calculate N as the minimum value between input1 and the sum of TEMP_MIN_3_OUT + input3:\nAdd TEMP_MIN_3_OUT to input3.\nUse USER_MIN to compare input1 with the result of (TEMP_MIN_3_OUT + input3).\nAssign the smaller value to N.\nOutputs:\n\nThe Function Block should provide the following outputs:\nM: The maximum value derived from comparing input1 with the intermediate maximum value (TEMP_MAX_OUT).\nN: The minimum value derived from comparing input1 with another intermediate value (TEMP_MIN_3_OUT + input3).\nUPDATED_CYCLE: This is CYCLE + 1, indicating that the Function Block has been executed once.\n\n\nFUNCTION_BLOCK USER_MAX\nVAR_INPUT\nin1, in2 : DINT;\nEND_VAR\nVAR_OUTPUT\nOUT : DINT;\nEND_VAR\nBEGIN\nIF in1 > in2 THEN\nOUT := in1;\nELSE\nOUT := in2;\nEND_IF;\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK USER_MIN\nVAR_INPUT\nin1, in2 : DINT;\nEND_VAR\nVAR_OUTPUT\nOUT : DINT;\nEND_VAR\nBEGIN\nIF in1 < in2 THEN\nOUT := in1;\nELSE\nOUT := in2;\nEND_IF;\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK FB_ValueComparison\nVAR_INPUT\ninput1 : DINT := 0;\ninput2 : DINT := 0;\ninput3 : DINT := 0;\ninput4 : DINT := 0;\ninput5 : DINT := 0;\nCYCLE  : DINT := 0;\nEND_VAR\nVAR_OUTPUT\nM : DINT;\nN : DINT;\nUPDATED_CYCLE : DINT;\nEND_VAR\nVAR\nTEMP_MAX_OUT   : DINT;\nTEMP_MIN_2_OUT : DINT;\nTEMP_MIN_3_OUT : DINT;\nINSTANCE_MAX   : USER_MAX;\nINSTANCE_MIN   : USER_MIN;\nTEMP_MAX       : USER_MAX;\nTEMP_MIN_2     : USER_MIN;\nTEMP_MIN_3     : USER_MIN;\nEND_VAR\n\n\n\nEND_FUNCTION_BLOCK",
    "properties_to_be_validated": [
        {
            "property_description": "Ensure that the output M is always equal to input1 when input1 is greater than or equal to both input2 and input3.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.input1 >= instance.input2 AND instance.input1 >= instance.input3",
                    "2": "instance.M = instance.input1"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "If {instance.input1 >= instance.input2 AND instance.input1 >= instance.input3} is true at the end of the PLC cycle, then {instance.M = instance.input1} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that if input1 is less than input2, the output M should be equal to input2 when input2 is greater than or equal to input3.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.input1 < instance.input2 AND instance.input2 >= instance.input3",
                    "2": "instance.M = instance.input2"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "If {instance.input1 < instance.input2 AND instance.input2 >= instance.input3} is true at the end of the PLC cycle, then {instance.M = instance.input2} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that if input1 is less than input3, and input3 is greater than or equal to input2, the output M should be equal to input3.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.input1 < instance.input3 AND instance.input3 >= instance.input2",
                    "2": "instance.M = instance.input3"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "If {instance.input1 < instance.input3 AND instance.input3 >= instance.input2} is true at the end of the PLC cycle, then {instance.M = instance.input3} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that the output N is always equal to input1 when input1 is less than or equal to the calculated value involving input2, input3, input4, and input5.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.input1 <= (instance.input3 * instance.input4 + instance.input5 + instance.input2)",
                    "2": "instance.N = instance.input1"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "If {instance.input1 <= (instance.input3 * instance.input4 + instance.input5 + instance.input2)} is true at the end of the PLC cycle, then {instance.N = instance.input1} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that if input1 is greater than the calculated value involving input2, input3, input4, and input5, then output N should be equal to the calculated value.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.input1 > (instance.input3 * instance.input4 + instance.input5 + instance.input2)",
                    "2": "instance.N = (instance.input3 * instance.input4 + instance.input5 + instance.input2)"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "If {instance.input1 > (instance.input3 * instance.input4 + instance.input5 + instance.input2)} is true at the end of the PLC cycle, then {instance.N = (instance.input3 * instance.input4 + instance.input5 + instance.input2)} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that the output UPDATED_CYCLE is always equal to the input CYCLE incremented by 1.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.UPDATED_CYCLE = instance.CYCLE + 1"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "{instance.UPDATED_CYCLE = instance.CYCLE + 1} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Ensure that M and N are always within the valid range of a DINT.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.M <= 2147483647 AND instance.M >= -2147483648 AND instance.N <= 2147483647 AND instance.N >= -2147483648"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "{instance.M <= 2147483647 AND instance.M >= -2147483648 AND instance.N <= 2147483647 AND instance.N >= -2147483648} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Ensure that the output M is always equal to input1 when input1 is greater than or equal to both input2 and input3.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.input1 >= instance.input2 AND instance.input1 >= instance.input3",
                    "2": "instance.M = instance.input1"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "If {instance.input1 >= instance.input2 AND instance.input1 >= instance.input3} is true at the end of the PLC cycle, then {instance.M = instance.input1} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that if input1 is less than input2, the output M should be equal to input2 when input2 is greater than or equal to input3.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.input1 < instance.input2 AND instance.input2 >= instance.input3",
                    "2": "instance.M = instance.input2"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "If {instance.input1 < instance.input2 AND instance.input2 >= instance.input3} is true at the end of the PLC cycle, then {instance.M = instance.input2} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that if input1 is less than input3, and input3 is greater than or equal to input2, the output M should be equal to input3.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.input1 < instance.input3 AND instance.input3 >= instance.input2",
                    "2": "instance.M = instance.input3"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "If {instance.input1 < instance.input3 AND instance.input3 >= instance.input2} is true at the end of the PLC cycle, then {instance.M = instance.input3} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that the output UPDATED_CYCLE is always equal to the input CYCLE incremented by 1.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.UPDATED_CYCLE = instance.CYCLE + 1"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "{instance.UPDATED_CYCLE = instance.CYCLE + 1} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Ensure that M and N are always within the valid range of a DINT.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.M <= 2147483647 AND instance.M >= -2147483648 AND instance.N <= 2147483647 AND instance.N >= -2147483648"
                },
                "entry_point": "FB_ValueComparison",
                "pattern_description": "{instance.M <= 2147483647 AND instance.M >= -2147483648 AND instance.N <= 2147483647 AND instance.N >= -2147483648} is always true at the end of the PLC cycle."
            }
        }
    ]
}
{
    "id": "v1-M-4",
    "instruction": "Design a PLC program using structured text (ST code) that implements a function block to Calculate Fibonacci number.\nIf the output could exceed the bound of INT (at max 32767), then return the max value of 32767 based on Saturation Arithmetic ideas.\nThis program should include a main program that initializes an integer input value NN (default is 5)\nand calculates the Fibonacci sequence up to the NN-th term.\nThe final output should be the value of the NN-th Fibonacci number.\nEnsure the program handles edge cases for NN values less than or equal to 2 correctly by returning 1.\n\nFUNCTION_BLOCK FB_Fibonacci_Calculator\nVAR_INPUT\nN : DINT := 5;\nEND_VAR\nVAR_OUTPUT\nO : DINT := 1;\nEND_VAR\nVAR\nF1 : DINT := 1;\nF2 : DINT := 1;\nCNT : DINT := 2;\nEND_VAR\n\n\n\nEND_FUNCTION_BLOCK",
    "properties_to_be_validated": [
        {
            "property_description": "Verify that all assertions are satisfied in the program.",
            "property": {
                "job_req": "assertion"
            }
        },
        {
            "property_description": "Ensure that the output O is always a non-negative integer.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.O >= 0"
                },
                "pattern_description": "{instance.O >= 0} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Ensure that the output O is 1 if N is less than or equal to 2.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.N <= 2",
                    "2": "instance.O = 1"
                },
                "pattern_description": "If {instance.N <= 2} is true at the end of the PLC cycle, then {instance.O = 1} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that the program does not enter an infinite loop.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.CNT <= instance.N"
                },
                "pattern_description": "{instance.CNT <= instance.N} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Ensure that the output O is equal to the sum of the previous two Fibonacci numbers if N is greater than 2, unless saturation occurs.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.N > 2 AND instance.O < 32767",
                    "2": "instance.O = instance.F1 + instance.F2"
                },
                "pattern_description": "If {instance.N > 2 AND instance.O < 32767} is true at the end of the PLC cycle, then {instance.O = instance.F1 + instance.F2} should always be true at the end of the same cycle."
            }
        },
        {
            "property_description": "Ensure that the output O and intermediate values do not exceed 32767.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.O <= 32767 AND instance.F1 <= 32767 AND instance.F2 <= 32767"
                },
                "pattern_description": "{instance.O <= 32767 AND instance.F1 <= 32767 AND instance.F2 <= 32767} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Ensure that if overflow occurs, the output O is set to the maximum allowable value of 32767.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.O > 32767 OR instance.O < 0",
                    "2": "instance.O = 32767"
                },
                "pattern_description": "If {instance.O > 32767 OR instance.O < 0} is true at the end of the PLC cycle, then {instance.O = 32767} should always be true at the end of the same cycle."
            }
        }
    ]
}
{
    "id": "v1-M-5",
    "instruction": "Use structured text (ST code) to design a function block (FB) for monitoring start/stop signals and managing trigger and\nrising edge signals in a PLC program. This function block should have the following features:\n\n- 'ONS_Trig' should be set to 'TRUE' only when 'Start_Stop' changes from 'FALSE' to 'TRUE' (detecting the rising edge),\nwhere the previous state of 'Start_Stop' 'Rising_ONS'.\n- 'ON_OFF' should be updated based on XOR(ONS_Trig, ON_OFF), you can imply it with correct logic XOR syntax,\nor implement it in ST code.\n- 'Rising_ONS' should store the current value of 'Start_Stop' to help detect changes in the next PLC cycle.\n\n\nFUNCTION_BLOCK FB_MonitorStartStop\nVAR_INPUT\nStart_Stop  : BOOL;\nON_OFF      : BOOL;\nEND_VAR\nVAR_OUTPUT\nONS_Trig    : BOOL;\nRising_ONS  : BOOL;\nEND_VAR\n\n\nEND_FUNCTION_BLOCK",
    "properties_to_be_validated": [
        {
            "property_description": "Verify that all assertions are satisfied in the program.",
            "property": {
                "job_req": "assertion"
            }
        },
        {
            "property_description": "Verify that ONS_Trig is TRUE only when Start_Stop is TRUE and Rising_ONS was previously FALSE.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-reachability",
                "pattern_params": {
                    "0": "instance.ONS_Trig = TRUE"
                },
                "pattern_description": "It is possible to have {0} at the end of a cycle only if Start_Stop was TRUE and Rising_ONS was previously FALSE."
            }
        },
        {
            "property_description": "Verify that ON_OFF toggles only when ONS_Trig is TRUE.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-leadsto-trigger",
                "pattern_params": {
                    "0": "instance.ONS_Trig = TRUE",
                    "1": "instance.ON_OFF = TRUE",
                    "2": "instance.ON_OFF = FALSE"
                },
                "pattern_description": "If {0} is true at the end of a cycle, there was a change from {1} to {2} in the same or subsequent cycles."
            }
        },
        {
            "property_description": "Verify that Rising_ONS follows Start_Stop correctly.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-statechange-duringcycle",
                "pattern_params": {
                    "0": "instance.Start_Stop = TRUE",
                    "1": "instance.Rising_ONS = TRUE"
                },
                "pattern_description": "If {0} is true at the beginning of the PLC cycle, then {1} is always true at the end of the same cycle."
            }
        }
    ]
}
{
    "id": "v1-M-6",
    "instruction": "Use Structured Text (ST) to design a PLC function block named LatencyMonitor.\nThis block will monitor the latency of a specific node by updating error counts\nand tracking minimum and maximum latency values based on input conditions.\nThe function block has two input variables: `latency_xx_ms`,\nwhich represents the latency time in milliseconds, and `NODE_xx_STATUS`,\nwhich indicates the current status of the node.\n\nThe function block has four IN_OUT variables:\n`errors_xx`, which counts errors for the specific node;\n`errors_all`, which maintains a total error count;\n`min_latency_ms`, which stores the minimum observed latency;\nand `max_latency_ms`, which records the maximum observed latency.\n\nThe logic within the function block is as follows:\n1. If the `latency_xx_ms` is zero or if the `NODE_xx_STATUS` is not equal to 1, increment both `errors_xx` and `errors_all`.\n2. Check and update `min_latency_ms` from `latency_xx_ms` if `latency_xx_ms` is less than the current minimum or if the current minimum is negative.\n3. Check and update `max_latency_ms` from `latency_xx_ms` if `latency_xx_ms` is greater than the current maximum or if the current maximum is negative.\n\nEnsure that the function block efficiently updates the error counts and latency values each time it is called,\nallowing for accurate monitoring of node performance.\n\nFUNCTION_BLOCK LatencyMonitor\nVAR_INPUT\nlatency_xx_ms : DINT;            // Input latency time in milliseconds\nNODE_xx_STATUS : UDINT;          // Input node status\nEND_VAR\n\nVAR_IN_OUT\nerrors_xx : DINT;                // Error count for the specific node\nerrors_all : DINT;               // Total error count\nmin_latency_ms : DINT;           // Minimum latency observed\nmax_latency_ms : DINT;           // Maximum latency observed\nEND_VAR\n\n\n\nEND_FUNCTION_BLOCK",
    "properties_to_be_validated": [
        {
            "property_description": "Verify that all assertions are satisfied in the program.",
            "property": {
                "job_req": "assertion"
            }
        },
        {
            "property_description": "Verify that instance.errors_xx is incremented when instance.latency_xx_ms = 0 or instance.NODE_xx_STATUS <> 1 at the end of the PLC cycle.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-statechange-duringcycle",
                "pattern_params": {
                    "1": "(instance.latency_xx_ms = 0 OR instance.NODE_xx_STATUS <> 1) AND instance.errors_xx = 0",
                    "2": "instance.errors_xx = 1"
                },
                "pattern_description": "If {1} is true at the end of the PLC cycle, then {2} should always be true."
            }
        },
        {
            "property_description": "Verify that instance.errors_all is incremented when instance.latency_xx_ms = 0 or instance.NODE_xx_STATUS <> 1 at the end of the PLC cycle.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-statechange-duringcycle",
                "pattern_params": {
                    "1": "(instance.latency_xx_ms = 0 OR instance.NODE_xx_STATUS <> 1) AND instance.errors_all = 0",
                    "2": "instance.errors_all = 1"
                },
                "pattern_description": "If {1} is true at the end of the PLC cycle, then {2} should always be true."
            }
        },
        {
            "property_description": "Verify that instance.min_latency_ms is updated correctly based on instance.latency_xx_ms.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.latency_xx_ms < instance.min_latency_ms OR instance.min_latency_ms < 0",
                    "2": "instance.min_latency_ms = instance.latency_xx_ms"
                },
                "pattern_description": "If {1} is true at the end of the PLC cycle, then {2} should always be true."
            }
        },
        {
            "property_description": "Verify that instance.max_latency_ms is updated correctly based on instance.latency_xx_ms.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-implication",
                "pattern_params": {
                    "1": "instance.latency_xx_ms > instance.max_latency_ms OR instance.max_latency_ms < 0",
                    "2": "instance.max_latency_ms = instance.latency_xx_ms"
                },
                "pattern_description": "If {1} is true at the end of the PLC cycle, then {2} should always be true."
            }
        },
        {
            "property_description": "Verify that instance.min_latency_ms is always less than or equal to instance.max_latency_ms.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.min_latency_ms <= instance.max_latency_ms"
                },
                "pattern_description": "{1} is always true at the end of the PLC cycle."
            }
        }
    ]
}
{
    "id": "v1-M-7",
    "instruction": "Use structured text (ST code) to design a function block for controlling the LED color and motor direction based on two input button signals.\n\nThe function block should define input variables for left (PI_Button_Left)\nand right (PI_Button_Right) button presses, along with output variables for controlling the\nred LED (PI_LED_Red), green LED (PI_LED_Green), and motor direction (A_Motor_Left and A_Motor_Right).\n\nThe red LED should activate when the left signal (E_Left) is received,\nwhile the green LED should activate for the right signal (E_Right).\n\nThe motor should run to the left when the left button is not pressed (i.e., when PI_Button_Left is FALSE)\nand to the right when the right button is not pressed (i.e., when PI_Button_Right is FALSE).\n\nThe logic should ensure that the LED states and motor directions are updated accordingly based on these conditions.\n\nFUNCTION_BLOCK LED_Motor_Controller\nVAR_INPUT\nPI_Button_Left : BOOL;    // Button for motor left control\nPI_Button_Right : BOOL;   // Button for motor right control\nE_Left : BOOL;            // Signal to turn on red LED (left indicator)\nE_Right : BOOL;           // Signal to turn on green LED (right indicator)\nEND_VAR\n\nVAR_OUTPUT\nPI_LED_Red : BOOL;        // Red LED control output\nPI_LED_Green : BOOL;      // Green LED control output\nA_Motor_Left : BOOL;      // Motor control to turn left\nA_Motor_Right : BOOL;     // Motor control to turn right\nEND_VAR\n\n\nEND_FUNCTION_BLOCK",
    "properties_to_be_validated": [
        {
            "property_description": "Ensure that the red LED output is always activated when the left signal is received, regardless of the button state.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.PI_LED_Red = instance.E_Left"
                },
                "entry_point": "LED_Motor_Controller",
                "pattern_description": "{instance.PI_LED_Red = instance.E_Left} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Ensure that the green LED output is always activated when the right signal is received, regardless of the button state.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.PI_LED_Green = instance.E_Right"
                },
                "entry_point": "LED_Motor_Controller",
                "pattern_description": "{instance.PI_LED_Green = instance.E_Right} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Ensure that the motor turns left when the left button is not pressed.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.A_Motor_Left = NOT(instance.PI_Button_Left)"
                },
                "entry_point": "LED_Motor_Controller",
                "pattern_description": "{instance.A_Motor_Left = NOT(instance.PI_Button_Left)} is always true at the end of the PLC cycle."
            }
        },
        {
            "property_description": "Ensure that the motor turns right when the right button is not pressed.",
            "property": {
                "job_req": "pattern",
                "pattern_id": "pattern-invariant",
                "pattern_params": {
                    "1": "instance.A_Motor_Right = NOT(instance.PI_Button_Right)"
                },
                "entry_point": "LED_Motor_Controller",
                "pattern_description": "{instance.A_Motor_Right = NOT(instance.PI_Button_Right)} is always true at the end of the PLC cycle."
            }
        }
    ]
}
