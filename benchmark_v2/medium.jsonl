{
  "instruction": "Create a PLC function block in Structured Text (ST) to manage an automated cotton candy machine, controlling sugar feeding and motor spinning speed. The function block should have two input variables: SugarLevel (REAL) for measuring the current sugar level and SpinningSpeed (INT) for specifying the desired spinning speed. It should produce two output variables: SugarFeeder (BOOL) for controlling the sugar feeding mechanism and MotorSpeed (INT) for managing the spinning motor speed. The logic must ensure that the sugar feeder is activated when the sugar level is below 10.0 units and deactivated when the level is at or above this threshold. The motor speed should be set to the input spinning speed if it is positive; otherwise, it should be set to 0 when the input speed is 0 or negative. Implement this logic in the function block to ensure efficient control of the cotton candy machine's operations. Please ensure that the output ST code complies with syntax rules. Structure the function block as follows: \n\nFUNCTION_BLOCK CottonCandyMachine\nVAR_INPUT\n    SugarLevel : REAL; (* Input for sugar level *)\n    SpinningSpeed : INT; (* Input for spinning speed *)\nEND_VAR\nVAR_OUTPUT\n    SugarFeeder : BOOL; (* Output to control sugar feeding *)\n    MotorSpeed : INT; (* Output to control spinning motor speed *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the sugar feeder is activated when the sugar level is below 10.0 units.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.SugarLevel < 10.0",
          "1": "instance.SugarFeeder = TRUE"
        },
        "pattern_description": "If {instance.SugarLevel < 10.0} is true at the end of the PLC cycle, then {instance.SugarFeeder = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the sugar feeder is deactivated when the sugar level is at or above 10.0 units.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.SugarLevel >= 10.0",
          "1": "instance.SugarFeeder = FALSE"
        },
        "pattern_description": "If {instance.SugarLevel >= 10.0} is true at the end of the PLC cycle, then {instance.SugarFeeder = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the motor speed is set to the input spinning speed when it's positive.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.SpinningSpeed > 0",
          "1": "instance.MotorSpeed = instance.SpinningSpeed"
        },
        "pattern_description": "If {instance.SpinningSpeed > 0} is true at the end of the PLC cycle, then {instance.MotorSpeed = instance.SpinningSpeed} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the motor speed is set to 0 when the input spinning speed is 0 or negative.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.SpinningSpeed <= 0",
          "1": "instance.MotorSpeed = 0"
        },
        "pattern_description": "If {instance.SpinningSpeed <= 0} is true at the end of the PLC cycle, then {instance.MotorSpeed = 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the motor speed is always non-negative.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.MotorSpeed >= 0"
        },
        "pattern_description": "{instance.MotorSpeed >= 0} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-1"
}
{
  "instruction": "Design a FUNCTION_BLOCK in Structured Text (ST) for a smart irrigation system that manages water delivery based on soil moisture levels and weather forecasts. The system should accept inputs from two soil moisture sensors, which are represented as REAL values, and a weather forecast input as an integer, where 0 indicates sunny, 1 indicates rainy, and 2 indicates cloudy conditions. There should be a constant soil moisture threshold for making irrigation decisions, set to a positive value to ensure proper functionality. The water pump should be controlled as a boolean output based on the following logic: first, activate the pump if either SoilMoistureSensor1 or SoilMoistureSensor2 reads below the defined threshold and the WeatherForecast is sunny (0). Second, regardless of the current state, ensure that the pump is deactivated if the WeatherForecast indicates rain (1). Furthermore, the pump should remain off if both soil moisture sensors read above the threshold or if the weather is not sunny. This structured approach ensures efficient water use and responsiveness to changing environmental conditions. Ensure that the output ST code complies with syntax rules. The function block should follow this structure: \n\nFUNCTION_BLOCK SmartIrrigationSystem\nVAR_INPUT\n    SoilMoistureSensor1 : REAL;\n    SoilMoistureSensor2 : REAL;\n    WeatherForecast : INT; (* 0: Sunny, 1: Rainy, 2: Cloudy *)\nEND_VAR\n\nVAR_OUTPUT\n    WaterPump : BOOL;\nEND_VAR\n\nVAR\n    SoilMoistureThreshold : REAL := 30.0;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the water pump is activated when soil moisture is below the threshold and the weather is sunny.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "(instance.SoilMoistureSensor1 < instance.SoilMoistureThreshold OR instance.SoilMoistureSensor2 < instance.SoilMoistureThreshold) AND instance.WeatherForecast = 0",
          "1": "instance.WaterPump = TRUE"
        },
        "pattern_description": "If {(instance.SoilMoistureSensor1 < instance.SoilMoistureThreshold OR instance.SoilMoistureSensor2 < instance.SoilMoistureThreshold) AND instance.WeatherForecast = 0} is true at the end of the PLC cycle, then {instance.WaterPump = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the water pump is deactivated when the weather forecast is rainy.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WeatherForecast = 1",
          "1": "instance.WaterPump = FALSE"
        },
        "pattern_description": "If {instance.WeatherForecast = 1} is true at the end of the PLC cycle, then {instance.WaterPump = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the water pump remains off when soil moisture is above the threshold or the weather is not sunny.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "(instance.SoilMoistureSensor1 >= instance.SoilMoistureThreshold AND instance.SoilMoistureSensor2 >= instance.SoilMoistureThreshold) OR instance.WeatherForecast <> 0",
          "1": "instance.WaterPump = FALSE"
        },
        "pattern_description": "If {(instance.SoilMoistureSensor1 >= instance.SoilMoistureThreshold AND instance.SoilMoistureSensor2 >= instance.SoilMoistureThreshold) OR instance.WeatherForecast <> 0} is true at the end of the PLC cycle, then {instance.WaterPump = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the soil moisture threshold is always a positive value.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "0": "instance.SoilMoistureThreshold > 0.0"
        },
        "pattern_description": "{instance.SoilMoistureThreshold > 0.0} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-2"
}
{
  "instruction": "Design a FUNCTION_BLOCK in Structured Text (ST) for an automatic door control system suitable for a retail environment. The system should accept a boolean input from a proximity sensor to determine whether an object is nearby. Additionally, it should take a DINT input that represents the elapsed time since the door was last opened, in milliseconds. The function block will control a boolean output to indicate whether the door is open or closed. A constant should be defined for the duration that the door is to remain open, set at 5000 milliseconds (or 5 seconds). The door should open when the proximity sensor is activated, provided the door is currently closed. While the proximity sensor remains active, the door must stay open. If the proximity sensor becomes inactive or if the defined open duration has elapsed, the door should then close. This design ensures safe operation by preventing rapid open/close cycles and maintaining clear instructi ons for operation. Please ensure that the output ST code adheres to the applicable syntax rules. The function block should be structured as follows:\n\nFUNCTION_BLOCK AutomaticDoorControl\nVAR_INPUT\n    ProximitySensor : BOOL;\n    ElapsedTime : DINT; (* Changed from TIME to DINT, representing milliseconds *)\nEND_VAR\n\nVAR_OUTPUT\n    DoorOpen : BOOL;\nEND_VAR\n\nVAR\n    DoorOpenDuration : DINT := 5000; (* 5 seconds in milliseconds *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the door remains open while the proximity sensor is active and the open duration has not elapsed.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ProximitySensor = TRUE AND instance.ElapsedTime < instance.DoorOpenDuration",
          "1": "instance.DoorOpen = TRUE"
        },
        "pattern_description": "If {instance.ProximitySensor = TRUE AND instance.ElapsedTime < instance.DoorOpenDuration} is true at the end of the PLC cycle, then {instance.DoorOpen = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the door closes when the proximity sensor is inactive.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ProximitySensor = FALSE",
          "1": "instance.DoorOpen = FALSE"
        },
        "pattern_description": "If {instance.ProximitySensor = FALSE} is true at the end of the PLC cycle, then {instance.DoorOpen = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the door open duration is always positive.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "0": "instance.DoorOpenDuration > 0"
        },
        "pattern_description": "{instance.DoorOpenDuration > 0} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-3"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for a wastewater treatment plant named 'WastewaterControl'. The function block should have inputs for inlet flow rate (InFlow), outlet flow rate (OutFlow), pH level (pH), and tank level (TankLvl). It should control two pumps (Pump1 and Pump2) and two valves (Valve1 and Valve2). Implement the following control logic:\nTurn on Pump1 when the inlet flow rate is below 100.0, otherwise turn it off.\nTurn on Pump2 when the outlet flow rate is above 90.0, otherwise turn it off.\nOpen Valve1 when the pH level is below 7.0 for pH adjustment, otherwise close it.\nOpen Valve2 when the tank level is above 80.0 for drainage, otherwise close it.\nEnsure that the pumps and valves are controlled based on these sensor readings and thresholds at the end of each PLC cycle.Please ensure that the output ST code complies with the syntax rules. The function block should use the following structure:\n\nFUNCTION_BLOCK WastewaterControl\nVAR_INPUT\n    InFlow : REAL;\n    OutFlow : REAL;\n    pH : REAL;\n    TankLvl : REAL;\nEND_VAR\n\nVAR_OUTPUT\n    Pump1 : BOOL;\n    Pump2 : BOOL;\n    Valve1 : BOOL;\n    Valve2 : BOOL;\nEND_VAR\n\nVAR\n    LowInFlow : REAL := 100.0;\n    HighOutFlow : REAL := 90.0;\n    DesiredPH : REAL := 7.0;\n    HighTankLvl : REAL := 80.0;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that Pump1 is on when the inlet flow is low.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.InFlow >= 100.0 OR instance.Pump1 = TRUE"
        },
        "pattern_description": "{instance.InFlow >= 100.0 OR instance.Pump1 = TRUE} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that Pump2 is on when the outlet flow is high.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.OutFlow <= 90.0 OR instance.Pump2 = TRUE"
        },
        "pattern_description": "{instance.OutFlow <= 90.0 OR instance.Pump2 = TRUE} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that Valve1 is open when the pH is low.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.pH >= 7.0 OR instance.Valve1 = TRUE"
        },
        "pattern_description": "{instance.pH >= 7.0 OR instance.Valve1 = TRUE} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that Valve2 is open when the tank level is high.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.TankLvl <= 80.0 OR instance.Valve2 = TRUE"
        },
        "pattern_description": "{instance.TankLvl <= 80.0 OR instance.Valve2 = TRUE} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-4"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for an automated library book sorting system named 'BookSorting'. The function block should have inputs for three RFID readers (RFID1, RFID2, RFID3) and outputs for a conveyor motor (Motor) and three sorting bins (Bin1, Bin2, Bin3). Implement the following control logic:\n\nActivate the conveyor motor (Motor) when any RFID reader detects a book.\nOpen Bin1 when RFID1 detects a book, keeping other bins closed.\nOpen Bin2 when RFID2 detects a book, keeping other bins closed.\nOpen Bin3 when RFID3 detects a book, keeping other bins closed.\nWhen no RFID readers detect a book, stop the motor and close all bins.\n\nEnsure that only one bin is open at a time and that the motor and bins are controlled based on the RFID readings at the end of each PLC cycle. Please ensure that the output ST code complies with the syntax rules.The function block should use the following structure:\n\nFUNCTION_BLOCK BookSorting\nVAR_INPUT\n    RFID1 : BOOL;\n    RFID2 : BOOL;\n    RFID3 : BOOL;\nEND_VAR\n\nVAR_OUTPUT\n    Motor : BOOL;\n    Bin1 : BOOL;\n    Bin2 : BOOL;\n    Bin3 : BOOL;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the conveyor motor is on when any RFID reader detects a book.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.RFID1 OR instance.RFID2 OR instance.RFID3) = instance.Motor"
        },
        "pattern_description": "{(instance.RFID1 OR instance.RFID2 OR instance.RFID3) = instance.Motor} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that only one bin is open at a time.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.Bin1 AND NOT instance.Bin2 AND NOT instance.Bin3) OR (instance.Bin2 AND NOT instance.Bin1 AND NOT instance.Bin3) OR (instance.Bin3 AND NOT instance.Bin1 AND NOT instance.Bin2) OR (NOT instance.Bin1 AND NOT instance.Bin2 AND NOT instance.Bin3)"
        },
        "pattern_description": "{(instance.Bin1 AND NOT instance.Bin2 AND NOT instance.Bin3) OR (instance.Bin2 AND NOT instance.Bin1 AND NOT instance.Bin3) OR (instance.Bin3 AND NOT instance.Bin1 AND NOT instance.Bin2) OR (NOT instance.Bin1 AND NOT instance.Bin2 AND NOT instance.Bin3)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that when no RFID reader detects a book, all bins are closed and the motor is off.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.RFID1 OR instance.RFID2 OR instance.RFID3) OR (NOT instance.Motor AND NOT instance.Bin1 AND NOT instance.Bin2 AND NOT instance.Bin3)"
        },
        "pattern_description": "{(instance.RFID1 OR instance.RFID2 OR instance.RFID3) OR (NOT instance.Motor AND NOT instance.Bin1 AND NOT instance.Bin2 AND NOT instance.Bin3)} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-5"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for managing an automatic flower arranging machine named 'FlowerArrangingMachine'. The function block should have inputs for flower type (FlowerTypeSensor : INT) and flower color (FlowerColorSensor : INT). It should control an arranging mechanism (ArrangingMechanism : INT) and a conveyor belt (ConveyorBelt : BOOL). Implement the following control logic:\n\nSet ArrangingMechanism to 1 when FlowerTypeSensor is 1 and FlowerColorSensor is 1 (red type 1 flower).\nSet ArrangingMechanism to 2 when FlowerTypeSensor is 1 and FlowerColorSensor is 2 (blue type 1 flower).\nSet ArrangingMechanism to 3 when FlowerTypeSensor is 2 and FlowerColorSensor is 1 (red type 2 flower).\nSet ArrangingMechanism to 4 when FlowerTypeSensor is 2 and FlowerColorSensor is 2 (blue type 2 flower).\nSet ArrangingMechanism to 0 for any other combination of FlowerTypeSensor and FlowerColorSensor values.\nSet ConveyorBelt to TRUE when ArrangingMechanism is not 0, and FALSE otherwise.\n\nEnsure that the arranging mechanism and conveyor belt are controlled based on the flower type and color sensor readings at the end of each PLC cycle. Please ensure that the output ST code complies with the syntax rules.The function block should use the following structure:\n\nFUNCTION_BLOCK FlowerArrangingMachine\nVAR_INPUT\n    FlowerTypeSensor : INT; (* Input for detecting flower type *)\n    FlowerColorSensor : INT; (* Input for detecting flower color *)\nEND_VAR\nVAR_OUTPUT\n    ArrangingMechanism : INT; (* Output for controlling arranging mechanism *)\n    ConveyorBelt : BOOL; (* Output for controlling conveyor belt *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that ArrangingMechanism is set to 1 when FlowerTypeSensor is 1 and FlowerColorSensor is 1 (red type 1 flower).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.FlowerTypeSensor = 1 AND instance.FlowerColorSensor = 1",
          "1": "instance.ArrangingMechanism = 1"
        },
        "pattern_description": "If {instance.FlowerTypeSensor = 1 AND instance.FlowerColorSensor = 1} is true at the end of the PLC cycle, then {instance.ArrangingMechanism = 1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that ArrangingMechanism is set to 2 when FlowerTypeSensor is 1 and FlowerColorSensor is 2 (blue type 1 flower).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.FlowerTypeSensor = 1 AND instance.FlowerColorSensor = 2",
          "1": "instance.ArrangingMechanism = 2"
        },
        "pattern_description": "If {instance.FlowerTypeSensor = 1 AND instance.FlowerColorSensor = 2} is true at the end of the PLC cycle, then {instance.ArrangingMechanism = 2} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that ArrangingMechanism is set to 3 when FlowerTypeSensor is 2 and FlowerColorSensor is 1 (red type 2 flower).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.FlowerTypeSensor = 2 AND instance.FlowerColorSensor = 1",
          "1": "instance.ArrangingMechanism = 3"
        },
        "pattern_description": "If {instance.FlowerTypeSensor = 2 AND instance.FlowerColorSensor = 1} is true at the end of the PLC cycle, then {instance.ArrangingMechanism = 3} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that ArrangingMechanism is set to 4 when FlowerTypeSensor is 2 and FlowerColorSensor is 2 (blue type 2 flower).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.FlowerTypeSensor = 2 AND instance.FlowerColorSensor = 2",
          "1": "instance.ArrangingMechanism = 4"
        },
        "pattern_description": "If {instance.FlowerTypeSensor = 2 AND instance.FlowerColorSensor = 2} is true at the end of the PLC cycle, then {instance.ArrangingMechanism = 4} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that ArrangingMechanism is set to 0 for unknown flower type or color combinations.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "(instance.FlowerTypeSensor <> 1 AND instance.FlowerTypeSensor <> 2) OR (instance.FlowerColorSensor <> 1 AND instance.FlowerColorSensor <> 2)",
          "1": "instance.ArrangingMechanism = 0"
        },
        "pattern_description": "If {(instance.FlowerTypeSensor <> 1 AND instance.FlowerTypeSensor <> 2) OR (instance.FlowerColorSensor <> 1 AND instance.FlowerColorSensor <> 2)} is true at the end of the PLC cycle, then {instance.ArrangingMechanism = 0} should always be true."
      }
    }
  ],
  "id": "v2-M-6"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for a home brewing system named 'HomeBrewingSystem'. The function block should have inputs for temperature (TemperatureSensor : REAL), water flow (WaterFlowSensor : REAL), brewing start time (BrewingStartTime : TIME), and brewing duration (BrewingDuration : TIME). It should control a heating element (HeatingElement : BOOL), an agitation motor (AgitationMotor : BOOL), a hops dispenser (HopsDispenser : BOOL), and a fermentation tank (FermentationTank : BOOL). Implement the following control logic:\n\nActivate the heating element (HeatingElement := TRUE) when the temperature is below 65.0°C, otherwise deactivate it.\nActivate the agitation motor (AgitationMotor := TRUE) when the water flow is above 0.5 units, otherwise deactivate it.\nActivate the hops dispenser (HopsDispenser := TRUE) after 5 hours of brewing, otherwise keep it deactivated.\nActivate the fermentation tank (FermentationTank := TRUE) after 48 hours of brewing, otherwise keep it deactivated.\n\nEnsure that all components are controlled based on the sensor readings and time parameters at the end of each PLC cycle. Please ensure that the output ST code complies with the syntax rules.The function block should use the following structure:\n\nFUNCTION_BLOCK HomeBrewingSystem\nVAR_INPUT\n    TemperatureSensor : REAL; (* Input for temperature measurement *)\n    WaterFlowSensor : REAL; (* Input for water flow measurement *)\n    BrewingStartTime : TIME; (* Input for brewing start time *)\n    BrewingDuration : TIME; (* Input for brewing duration *)\nEND_VAR\nVAR_OUTPUT\n    HeatingElement : BOOL; (* Output for heating element *)\n    AgitationMotor : BOOL; (* Output for agitation motor *)\n    HopsDispenser : BOOL; (* Output for hops dispenser *)\n    FermentationTank : BOOL; (* Output for fermentation tank *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the heating element is activated when the temperature is below 65.0°C.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor < 65.0",
          "1": "instance.HeatingElement = TRUE"
        },
        "pattern_description": "If {instance.TemperatureSensor < 65.0} is true at the end of the PLC cycle, then {instance.HeatingElement = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the heating element is deactivated when the temperature is at or above 65.0°C.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor >= 65.0",
          "1": "instance.HeatingElement = FALSE"
        },
        "pattern_description": "If {instance.TemperatureSensor >= 65.0} is true at the end of the PLC cycle, then {instance.HeatingElement = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the agitation motor is activated when the water flow is above 0.5 units.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WaterFlowSensor > 0.5",
          "1": "instance.AgitationMotor = TRUE"
        },
        "pattern_description": "If {instance.WaterFlowSensor > 0.5} is true at the end of the PLC cycle, then {instance.AgitationMotor = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the agitation motor is deactivated when the water flow is at or below 0.5 units.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WaterFlowSensor <= 0.5",
          "1": "instance.AgitationMotor = FALSE"
        },
        "pattern_description": "If {instance.WaterFlowSensor <= 0.5} is true at the end of the PLC cycle, then {instance.AgitationMotor = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the hops dispenser is activated after 5 hours of brewing.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.BrewingStartTime + instance.BrewingDuration > T#5h",
          "1": "instance.HopsDispenser = TRUE"
        },
        "pattern_description": "If {instance.BrewingStartTime + instance.BrewingDuration > T#5h} is true at the end of the PLC cycle, then {instance.HopsDispenser = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the hops dispenser is deactivated before 5 hours of brewing.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.BrewingStartTime + instance.BrewingDuration <= T#5h",
          "1": "instance.HopsDispenser = FALSE"
        },
        "pattern_description": "If {instance.BrewingStartTime + instance.BrewingDuration <= T#5h} is true at the end of the PLC cycle, then {instance.HopsDispenser = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-7"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for an automatic document filing system named 'DocumentFilingSystem'. The function block should have inputs for document detection (DocumentInlet : BOOL) and category selection (CategorySelector : INT). It should control a conveyor motor (ConveyorMotor : BOOL) and four storage bins (StorageBin1, StorageBin2, StorageBin3, StorageBin4 : BOOL). Implement the following control logic:\n\nActivate the conveyor motor (ConveyorMotor := TRUE) when a document is detected (DocumentInlet = TRUE) and a valid category (1-4) is selected.\nActivate StorageBin1 when CategorySelector is 1 and a document is detected.\nActivate StorageBin2 when CategorySelector is 2 and a document is detected.\nActivate StorageBin3 when CategorySelector is 3 and a document is detected.\nActivate StorageBin4 when CategorySelector is 4 and a document is detected.\nDeactivate all outputs (ConveyorMotor and all StorageBins) when no document is detected (DocumentInlet = FALSE) or an invalid category (CategorySelector < 1 or > 4) is selected.\n\nEnsure that only one storage bin is activated at a time and the conveyor motor is stopped when no document is being processed. Please ensure that the output ST code complies with the syntax rules.The function block should use the following structure:\n\nFUNCTION_BLOCK DocumentFilingSystem\nVAR_INPUT\n    DocumentInlet : BOOL; (* Input to detect the arrival of a document *)\n    CategorySelector : INT; (* Input to select the document category *)\nEND_VAR\nVAR_OUTPUT\n    ConveyorMotor : BOOL; (* Output to control the conveyor motor *)\n    StorageBin1 : BOOL; (* Output to activate storage bin 1 *)\n    StorageBin2 : BOOL; (* Output to activate storage bin 2 *)\n    StorageBin3 : BOOL; (* Output to activate storage bin 3 *)\n    StorageBin4 : BOOL; (* Output to activate storage bin 4 *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the conveyor motor is activated when a document is detected and a valid category is selected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DocumentInlet = TRUE AND (instance.CategorySelector >= 1 AND instance.CategorySelector <= 4)",
          "1": "instance.ConveyorMotor = TRUE"
        },
        "pattern_description": "If {instance.DocumentInlet = TRUE AND (instance.CategorySelector >= 1 AND instance.CategorySelector <= 4)} is true at the end of the PLC cycle, then {instance.ConveyorMotor = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the conveyor motor is deactivated when no document is detected or an invalid category is selected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DocumentInlet = FALSE OR instance.CategorySelector < 1 OR instance.CategorySelector > 4",
          "1": "instance.ConveyorMotor = FALSE"
        },
        "pattern_description": "If {instance.DocumentInlet = FALSE OR instance.CategorySelector < 1 OR instance.CategorySelector > 4} is true at the end of the PLC cycle, then {instance.ConveyorMotor = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that Storage Bin 1 is activated only when Category 1 is selected and a document is detected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DocumentInlet = TRUE AND instance.CategorySelector = 1",
          "1": "instance.StorageBin1 = TRUE AND instance.StorageBin2 = FALSE AND instance.StorageBin3 = FALSE AND instance.StorageBin4 = FALSE"
        },
        "pattern_description": "If {instance.DocumentInlet = TRUE AND instance.CategorySelector = 1} is true at the end of the PLC cycle, then {instance.StorageBin1 = TRUE AND instance.StorageBin2 = FALSE AND instance.StorageBin3 = FALSE AND instance.StorageBin4 = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that Storage Bin 2 is activated only when Category 2 is selected and a document is detected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DocumentInlet = TRUE AND instance.CategorySelector = 2",
          "1": "instance.StorageBin1 = FALSE AND instance.StorageBin2 = TRUE AND instance.StorageBin3 = FALSE AND instance.StorageBin4 = FALSE"
        },
        "pattern_description": "If {instance.DocumentInlet = TRUE AND instance.CategorySelector = 2} is true at the end of the PLC cycle, then {instance.StorageBin1 = FALSE AND instance.StorageBin2 = TRUE AND instance.StorageBin3 = FALSE AND instance.StorageBin4 = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-8"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for a museum climate control system named 'MuseumClimateControl'. The function block should have inputs for humidity (HumiditySensor : REAL), temperature (TemperatureSensor : REAL), and light level (LightSensor : BOOL). It should control HVAC (HVACSystem : BOOL), humidifier (Humidifier : BOOL), dehumidifier (Dehumidifier : BOOL), and lighting (LightControl : BOOL) systems. Implement the following control logic:\n\nActivate the humidifier when humidity is below 50.0%, and the dehumidifier when it's above 50.0%. Ensure both are off when humidity is exactly 50.0%.\nTurn on the HVAC system when temperature is below or above 20.0°C, and turn it off when temperature is exactly 20.0°C.\nTurn off the lights when the light sensor detects brightness above the threshold (LightSensor = TRUE AND LightThreshold = TRUE), otherwise turn them on.\nEnsure that the humidifier and dehumidifier are never on simultaneously.\nPlease ensure that the output ST code complies with the syntax rules.The function block should use the following structure:\n\nFUNCTION_BLOCK MuseumClimateControl\nVAR_INPUT\n    HumiditySensor : REAL;\n    TemperatureSensor : REAL;\n    LightSensor : BOOL;\nEND_VAR\n\nVAR_OUTPUT\n    HVACSystem : BOOL;\n    Humidifier : BOOL;\n    Dehumidifier : BOOL;\n    LightControl : BOOL;\nEND_VAR\n\nVAR\n    TargetHumidity : REAL := 50.0;\n    TargetTemperature : REAL := 20.0;\n    LightThreshold : BOOL := TRUE;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the humidifier is on when humidity is below the target.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.HumiditySensor < 50.0",
          "1": "instance.Humidifier = TRUE AND instance.Dehumidifier = FALSE"
        },
        "pattern_description": "If {instance.HumiditySensor < 50.0} is true at the end of the PLC cycle, then {instance.Humidifier = TRUE AND instance.Dehumidifier = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the dehumidifier is on when humidity is above the target.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.HumiditySensor > 50.0",
          "1": "instance.Humidifier = FALSE AND instance.Dehumidifier = TRUE"
        },
        "pattern_description": "If {instance.HumiditySensor > 50.0} is true at the end of the PLC cycle, then {instance.Humidifier = FALSE AND instance.Dehumidifier = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that both humidifier and dehumidifier are off when humidity is at the target.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.HumiditySensor = 50.0",
          "1": "instance.Humidifier = FALSE AND instance.Dehumidifier = FALSE"
        },
        "pattern_description": "If {instance.HumiditySensor = 50.0} is true at the end of the PLC cycle, then {instance.Humidifier = FALSE AND instance.Dehumidifier = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the HVAC system is on when temperature is below the target.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor < 20.0",
          "1": "instance.HVACSystem = TRUE"
        },
        "pattern_description": "If {instance.TemperatureSensor < 20.0} is true at the end of the PLC cycle, then {instance.HVACSystem = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the HVAC system is on when temperature is above the target.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor > 20.0",
          "1": "instance.HVACSystem = TRUE"
        },
        "pattern_description": "If {instance.TemperatureSensor > 20.0} is true at the end of the PLC cycle, then {instance.HVACSystem = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the HVAC system is off when temperature is at the target.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor = 20.0",
          "1": "instance.HVACSystem = FALSE"
        },
        "pattern_description": "If {instance.TemperatureSensor = 20.0} is true at the end of the PLC cycle, then {instance.HVACSystem = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the lights are off when the light sensor detects brightness above the threshold.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.LightSensor = TRUE AND instance.LightThreshold = TRUE",
          "1": "instance.LightControl = FALSE"
        },
        "pattern_description": "If {instance.LightSensor = TRUE AND instance.LightThreshold = TRUE} is true at the end of the PLC cycle, then {instance.LightControl = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the lights are on when the light sensor detects darkness or is below the threshold.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.LightSensor = FALSE OR instance.LightThreshold = FALSE",
          "1": "instance.LightControl = TRUE"
        },
        "pattern_description": "If {instance.LightSensor = FALSE OR instance.LightThreshold = FALSE} is true at the end of the PLC cycle, then {instance.LightControl = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the humidifier and dehumidifier are never on simultaneously.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "0": "instance.Humidifier = TRUE AND instance.Dehumidifier = TRUE"
        },
        "pattern_description": "{instance.Humidifier = TRUE AND instance.Dehumidifier = TRUE} is impossible at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-9"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for controlling an electric vehicle (EV) charging station named 'ChargingStationControl'. The function block should have inputs for EV connection status (EVConnected : BOOL), battery voltage (EVVoltage : REAL), charging current (EVCurrent : REAL), state of charge (EVStateOfCharge : REAL), and charging timer (ChargingTimer : TIME). It should control an output to start or stop EV charging (EVCharging : BOOL). Implement the following control logic:\n\nStart charging (EVCharging := TRUE) only when all these conditions are met:\n- An EV is connected (EVConnected = TRUE)\n- EV voltage is above the minimum threshold (EVVoltage > 350.0)\n- EV current is at or below the maximum limit (EVCurrent <= 32.0)\n- EV is not fully charged (EVStateOfCharge < 100.0)\n- Charging time has not exceeded the maximum (ChargingTimer <= T#2h)\n\nStop charging (EVCharging := FALSE) if any of these conditions occur:\n- EV is disconnected (NOT EVConnected)\n- EV voltage falls below the minimum threshold (EVVoltage <= 350.0)\n- EV current exceeds the maximum limit (EVCurrent > 32.0)\n- EV is fully charged (EVStateOfCharge >= 100.0)\n- Maximum charging time is exceeded (ChargingTimer > T#2h)\n\nUse intermediate variables (VoltageOK, CurrentOK, SOCNotFull, TimerOK) to store the status of each condition.Please ensure that the output ST code complies with the syntax rules. The function block should use the following structure:\n\nFUNCTION_BLOCK ChargingStationControl\nVAR_INPUT\n    EVConnected : BOOL;\n    EVVoltage : REAL;\n    EVCurrent : REAL;\n    EVStateOfCharge : REAL;\n    ChargingTimer : TIME;\nEND_VAR\n\nVAR_OUTPUT\n    EVCharging : BOOL;\nEND_VAR\n\nVAR\n    VoltageOK : BOOL;\n    CurrentOK : BOOL;\n    SOCNotFull : BOOL;\n    TimerOK : BOOL;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that charging only occurs when an EV is connected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EVCharging",
          "1": "instance.EVConnected"
        },
        "pattern_description": "If {instance.EVCharging} is true at the end of the PLC cycle, then {instance.EVConnected} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that charging only occurs when the battery voltage is above the minimum threshold.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EVCharging",
          "1": "instance.EVVoltage > 350000"
        },
        "pattern_description": "If {instance.EVCharging} is true at the end of the PLC cycle, then {instance.EVVoltage > 350000} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that charging only occurs when the charging current is within the allowed limit.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EVCharging",
          "1": "instance.EVCurrent <= 32000"
        },
        "pattern_description": "If {instance.EVCharging} is true at the end of the PLC cycle, then {instance.EVCurrent <= 32000} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that charging only occurs when the state of charge is less than 100%.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EVCharging",
          "1": "instance.EVStateOfCharge < 10000"
        },
        "pattern_description": "If {instance.EVCharging} is true at the end of the PLC cycle, then {instance.EVStateOfCharge < 10000} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that charging stops when the EV is disconnected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT instance.EVConnected",
          "1": "NOT instance.EVCharging"
        },
        "pattern_description": "If {NOT instance.EVConnected} is true at the end of the PLC cycle, then {NOT instance.EVCharging} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-10"
}
{
  "instruction": "Create a function block in Structured Text (ST) for an automatic greenhouse watering system that controls sprinkler activation based on soil moisture levels. The sprinklers should engage when soil moisture is below 30% and disengage when it exceeds 70%. Ensure the initial state of the sprinklers is off, and the system maintains these moisture parameters after each PLC cycle while considering system response delays if applicable. All transitions must satisfy assertions. Use the following function block structure: \n\nFUNCTION_BLOCK GreenhouseWateringSystem\nVAR\n    SoilMoistureSensor : REAL;   (* Input for soil moisture level (0-100%) *)\n    SprinklersOn : BOOL := FALSE;         (* Output for controlling sprinklers - on/off *)\n    ResponseDelay : TIME := T#5s;  (* Example response delay for the system *)\n    LastMoistureReading : REAL;\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the sprinklers are ON when the soil moisture is below 30%",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.SoilMoistureSensor < 30.0) = instance.SprinklersOn"
        },
        "pattern_description": "{(instance.SoilMoistureSensor < 30.0) = instance.SprinklersOn} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the sprinklers are OFF when the soil moisture is greater than or equal to 70%",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.SoilMoistureSensor >= 70.0) = (NOT instance.SprinklersOn)"
        },
        "pattern_description": "{(instance.SoilMoistureSensor >= 70.0) = (NOT instance.SprinklersOn)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the SoilMoistureSensor input is within the valid range of 0-100%",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.SoilMoistureSensor >= 0.0 AND instance.SoilMoistureSensor <= 100.0"
        },
        "pattern_description": "{instance.SoilMoistureSensor >= 0.0 AND instance.SoilMoistureSensor <= 100.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Verify that it's possible for the sprinklers to be ON",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-reachability",
        "pattern_params": {
          "1": "instance.SprinklersOn = TRUE"
        },
        "pattern_description": "It is possible to have {instance.SprinklersOn = TRUE} at the end of a cycle."
      }
    }
  ],
  "id": "v2-M-11"
}
{
  "instruction": "Develop a function block in Structured Text (ST) to control a robotic arm dedicated to sorting items based on color detection. The arm should sort items into designated red, green, or blue bins based on input from respective color sensors. It must activate the arm whenever any color sensor detects a color and ensure the arm stops when no colors are detected. Additionally, only one bin should be activated at a time in response to specific color detection. Furthermore, ensure the activation of the red bin is solely dependent on red color detection. Structure the function block as follows: \n\nFUNCTION_BLOCK RoboticArmColorSorting\nVAR_INPUT\n    ColorSensorRed : BOOL;   (* Input: Red color sensor *)\n    ColorSensorGreen : BOOL;  (* Input: Green color sensor *)\n    ColorSensorBlue : BOOL;   (* Input: Blue color sensor *)\nEND_VAR\n\nVAR_OUTPUT\n    RoboticArmMove : BOOL := FALSE;     (* Output: Control for robotic arm movement *)\n    BinRed : BOOL := FALSE;           (* Output: Activate red bin *)\n    BinGreen : BOOL := FALSE;         (* Output: Activate green bin *)\n    BinBlue : BOOL := FALSE;          (* Output: Activate blue bin *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the robotic arm activates when any color is detected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.ColorSensorRed OR instance.ColorSensorGreen OR instance.ColorSensorBlue) = instance.RoboticArmMove"
        },
        "pattern_description": "The robotic arm {instance.RoboticArmMove} should be true if any color sensor detects a color."
      }
    },
    {
      "property_description": "Ensure that the robotic arm stops when no color is detected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT (instance.ColorSensorRed OR instance.ColorSensorGreen OR instance.ColorSensorBlue) = NOT instance.RoboticArmMove"
        },
        "pattern_description": "The robotic arm {instance.RoboticArmMove} should be false when no color is detected."
      }
    },
    {
      "property_description": "Ensure that only one bin is activated at a time.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.BinRed AND NOT instance.BinGreen AND NOT instance.BinBlue) OR (instance.BinGreen AND NOT instance.BinRed AND NOT instance.BinBlue) OR (instance.BinBlue AND NOT instance.BinRed AND NOT instance.BinGreen) OR (NOT instance.BinRed AND NOT instance.BinGreen AND NOT instance.BinBlue)"
        },
        "pattern_description": "{(instance.BinRed AND NOT instance.BinGreen AND NOT instance.BinBlue) OR (instance.BinGreen AND NOT instance.BinRed AND NOT instance.BinBlue) OR (instance.BinBlue AND NOT instance.BinRed AND NOT instance.BinGreen) OR (NOT instance.BinRed AND NOT instance.BinGreen AND NOT instance.BinBlue)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the red bin is activated only when the red color is detected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.BinRed = instance.ColorSensorRed"
        },
        "pattern_description": "{instance.BinRed = instance.ColorSensorRed} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-12"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for controlling a coffee machine named CoffeeMachineControl. The function block should have inputs for start button (StartButton : BOOL) and elapsed time (ElapsedTime : DINT) in milliseconds. It should control outputs for water heating (WaterHeating : BOOL), grinder running (GrinderRunning : BOOL), brewing (Brewing : BOOL), and status indicators (WaterHeated, GrinderFinished, CoffeeReady : BOOL). Implement the following control logic:\n\nActivate water heating when the start button is pressed and water is not yet heated.\nAfter 30 seconds of water heating, set WaterHeated to TRUE and stop water heating.\nStart the grinder after water is heated, and run it for 15 seconds.\nAfter grinding, set GrinderFinished to TRUE and stop the grinder.\nStart brewing after grinding is finished, and run it for 60 seconds.\nAfter brewing, set CoffeeReady to TRUE and stop brewing.\nEnsure that only one process (water heating, grinding, or brewing) is active at a time.\nReset all outputs when the start button is not pressed.Please ensure that the output ST code complies with the syntax rules.The function block should use the following structure:\n\nFUNCTION_BLOCK CoffeeMachineControl\nVAR_INPUT\n    StartButton : BOOL;\n    ElapsedTime : DINT; (* Time elapsed since the start of the current process, in milliseconds *)\nEND_VAR\n\nVAR_OUTPUT\n    WaterHeating : BOOL;\n    GrinderRunning : BOOL;\n    Brewing : BOOL;\n    GrinderFinished : BOOL;\n    WaterHeated : BOOL;\n    CoffeeReady : BOOL;\nEND_VAR\n\nVAR\n    WaterHeatingDuration : DINT := 30000; (* 30 seconds in milliseconds *)\n    GrinderDuration : DINT := 15000; (* 15 seconds in milliseconds *)\n    BrewingDuration : DINT := 60000; (* 60 seconds in milliseconds *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that water heating starts when the start button is pressed and water is not yet heated.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton = TRUE AND instance.WaterHeated = FALSE",
          "1": "instance.WaterHeating = TRUE"
        },
        "pattern_description": "If {instance.StartButton = TRUE AND instance.WaterHeated = FALSE} is true at the end of the PLC cycle, then {instance.WaterHeating = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that water heating stops and water is considered heated after the heating duration.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton = TRUE AND instance.ElapsedTime >= instance.WaterHeatingDuration",
          "1": "instance.WaterHeating = FALSE AND instance.WaterHeated = TRUE"
        },
        "pattern_description": "If {instance.StartButton = TRUE AND instance.ElapsedTime >= instance.WaterHeatingDuration} is true at the end of the PLC cycle, then {instance.WaterHeating = FALSE AND instance.WaterHeated = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that all processes are stopped when the start button is not pressed.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton = FALSE",
          "1": "instance.WaterHeating = FALSE AND instance.GrinderRunning = FALSE AND instance.Brewing = FALSE AND instance.WaterHeated = FALSE AND instance.GrinderFinished = FALSE AND instance.CoffeeReady = FALSE"
        },
        "pattern_description": "If {instance.StartButton = FALSE} is true at the end of the PLC cycle, then {instance.WaterHeating = FALSE AND instance.GrinderRunning = FALSE AND instance.Brewing = FALSE AND instance.WaterHeated = FALSE AND instance.GrinderFinished = FALSE AND instance.CoffeeReady = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that only one process is active at a time.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "0": "(instance.WaterHeating AND NOT instance.GrinderRunning AND NOT instance.Brewing) OR (NOT instance.WaterHeating AND instance.GrinderRunning AND NOT instance.Brewing) OR (NOT instance.WaterHeating AND NOT instance.GrinderRunning AND instance.Brewing) OR (NOT instance.WaterHeating AND NOT instance.GrinderRunning AND NOT instance.Brewing)"
        },
        "pattern_description": "{(instance.WaterHeating AND NOT instance.GrinderRunning AND NOT instance.Brewing) OR (NOT instance.WaterHeating AND instance.GrinderRunning AND NOT instance.Brewing) OR (NOT instance.WaterHeating AND NOT instance.GrinderRunning AND instance.Brewing) OR (NOT instance.WaterHeating AND NOT instance.GrinderRunning AND NOT instance.Brewing)} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-13"
}
{
  "instruction": "Develop a new Structured Text (ST) program that mimics the functionality of the existing calculation logic\nencapsulated within a function block named FB_SimpleCalculation.\n\n\nAssign value of INPUT_VAR1 to OUTPUT_VAR1, then\nimplement a loop that multiplies OUTPUT_VAR1 (starting from INPUT_VAR1) by 2 for 5 iterations.\n\nAssign VAR2 to OUTPUT_VAR2, then\nImplement a second loop that increments VAR2 by 1 for 5 iterations.\n\nInputs:\n\nThe function block should accept an integer input named INPUT_VAR1, initialized to 2.\n\nOutputs:\n\nThe function block should produce two integer outputs:\nOUTPUT_VAR1: This output will hold the result of multiplying INPUT_VAR1 by 2 for a total of 5 iterations.\nOUTPUT_VAR2: This output will track the count of iterations, which shoule be incremented by 1 for a total of 5 iterations.\n\n\nFUNCTION_BLOCK FB_SimpleCalculation\nVAR_INPUT\nINPUT_VAR1 : INT := 2;\nVAR2 : INT := 0;\nEND_VAR\n\nVAR_OUTPUT\nOUTPUT_VAR1 : INT;\nOUTPUT_VAR2 : INT;\nEND_VAR\n\nVAR\nCOUNTER2 : INT := 0;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that OUTPUT_VAR1 is equal to INPUT_VAR1 multiplied by 32 at the end of the PLC cycle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.INPUT_VAR1 = 2",
          "2": "instance.OUTPUT_VAR1 = 64"
        },
        "pattern_description": "If {instance.INPUT_VAR1 = 2} is true at the end of the PLC cycle, then {instance.OUTPUT_VAR1 = 64} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that OUTPUT_VAR2 is equal to VAR2 + 5 if not exceeding limit of int.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.VAR2 + 5 <= 32767 AND instance.VAR2 + 5 >= -32768",
          "2": "instance.OUTPUT_VAR2 = instance.VAR2 + 5"
        },
        "pattern_description": "{instance.OUTPUT_VAR2 = instance.VAR2 + 5} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that OUTPUT_VAR1 is initialized correctly based on INPUT_VAR1 multiplied by 32 at the start of the PLC cycle  if not exceeding limit of int.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.INPUT_VAR1 * 32 <= 32767 AND instance.INPUT_VAR1 * 32 >= -32768",
          "2": "instance.OUTPUT_VAR1 = instance.INPUT_VAR1 * 32"
        },
        "pattern_description": "If {instance.OUTPUT_VAR1 = instance.INPUT_VAR1 * 32} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-14"
}
{
  "instruction": "Create a new Structured Text (ST) code that implements a function block similar to the following logic:\n\nDefine a POINT type with two integer fields: X and Y.\nCreate a function block named FB_PointOperations.\nThe function block should have:\nOne input variable: INPUT_VAR2 of type INT with a default value of 7.\nTwo output variables: OUTPUT_VAR1 of type POINT and OUTPUT_VAR3 of type POINT.\nAn additional internal variable VAR2 of type INT.\nInside the function block:\nAssign the value of INPUT_VAR2 to VAR2.\nSet OUTPUT_VAR1.X to 1 and OUTPUT_VAR1.Y to 2.\nSet OUTPUT_VAR3.X to 100 and OUTPUT_VAR3.Y to -7000.\n\nFUNCTION_BLOCK FB_ExpandedPoint\n    VAR_INPUT\n        INPUT_VAR2 : INT;\n        INPUT_VAR1_X : INT;\n        INPUT_VAR1_Y : INT;\n        INPUT_VAR3_X : INT := 1;\n        INPUT_VAR3_Y : INT := 2;\n    END_VAR\n\n    VAR_OUTPUT\n        OUTPUT_VAR2 : INT;\n        OUTPUT_VAR1_X : INT;\n        OUTPUT_VAR1_Y : INT;\n        OUTPUT_VAR3_X : INT;\n        OUTPUT_VAR3_Y : INT;\n    END_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that OUTPUT_VAR1_X is always equal to 1 at the end of the PLC cycle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.OUTPUT_VAR1_X = 1"
        },
        "pattern_description": "{instance.OUTPUT_VAR1_X = 1} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that OUTPUT_VAR1_Y is always equal to 2 at the end of the PLC cycle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.OUTPUT_VAR1_Y = 2"
        },
        "pattern_description": "{instance.OUTPUT_VAR1_Y = 2} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that OUTPUT_VAR3_X is always equal to 100 at the end of the PLC cycle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.OUTPUT_VAR3_X = 100"
        },
        "pattern_description": "{instance.OUTPUT_VAR3_X = 100} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that OUTPUT_VAR3_Y is always equal to -7000 at the end of the PLC cycle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.OUTPUT_VAR3_Y = -7000"
        },
        "pattern_description": "{instance.OUTPUT_VAR3_Y = -7000} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that OUTPUT_VAR2 is always equal to INPUT_VAR2 at the end of the PLC cycle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.OUTPUT_VAR2 = instance.INPUT_VAR2"
        },
        "pattern_description": "{instance.OUTPUT_VAR2 = instance.INPUT_VAR2} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-15"
}
{
  "instruction": "Design a PLC function block using Structured Text (ST) named FB_RealValueAdjuster.\nThe function block should accept a real (floating-point) input variable x_in\nand process it based on a series of conditional statements.\nThe function should follow these rules:\n\nIf the input value is exactly 0.0, add 1.0 to it.\nIf the input value is not 0.0, also add 1.0 to it.\nAdditionally, check for conditions where x_in is compared to 0.0 using equality and inequality operators and adjust the value by adding 1.0.\nThe function should also convert the real input to an integer and, if the integer conversion is not zero, add 1.0 to the original real input.\nThe final result should be assigned to an output variable x_out of type real.\n\nEnsure that the output is correct for all cases where x_in is positive, negative, or zero,\nand that real-to-integer conversion does not result in overflow. The function block must return the adjusted real value.\n\nFUNCTION_BLOCK FB_RealValueAdjuster\nVAR_INPUT\nx_in : REAL;\nEND_VAR\n\nVAR_OUTPUT\nx_out : REAL;\nEND_VAR\n\nVAR\nx : REAL;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that if the input x_in equals 0.0, the output x_out is incremented by 1.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.x_in = 0.0",
          "2": "instance.x_out = instance.x_in + 3"
        },
        "pattern_description": "If {instance.x_in = 0.0} is true at the end of the PLC cycle, then {instance.x_out = instance.x_in + 3} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that if the input x_in is not equal to 0.0 or -1, the output x_out is incremented by 2.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.x_in <> 0.0",
          "2": "instance.x_out = instance.x_in + 2"
        },
        "pattern_description": "If {instance.x_in <> 0.0} is true at the end of the PLC cycle, then {instance.x_out = instance.x_in + 1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that if the input x_in is -1, the output x_out is incremented by 1.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.x_in = -1",
          "2": "instance.x_out = instance.x_in + 1"
        },
        "pattern_description": "If {instance.x_in = -1} is true at the end of the PLC cycle, then {instance.x_out = instance.x_in + 1} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-16"
}
{
  "instruction": "Create a function block in Structured Text (ST) for a solar panel tracking control system that adjusts panel angles based on the time of day and solar intensity levels to maximize energy efficiency. Set the panel angle to zero during nighttime or when current time falls outside of the defined sunrise (6 AM) and sunset (6 PM) times. Adjust the panel to morning angle before noon, and evening angle after noon unless solar intensity is 90% or higher, in which case set the panel to noon angle for optimal performance. Make sure to keep the panel angle within 0 to 90 degrees irrespective of conditions. Structure the function block with: \n\nFUNCTION_BLOCK SolarPanelTracking\nVAR_INPUT\n    SolarIntensity : REAL;      (* Input: Solar intensity in percentage *)\n    CurrentTime : TIME;         (* Input: Current time of day *)\nEND_VAR\n\nVAR_OUTPUT\n    PanelAngle : REAL := 0.0;   (* Output: Panel angle in degrees *)\nEND_VAR\n\nVAR\n    SunriseTime : TIME := T#6H;    (* Sunrise time set to 6 AM *)\n    SunsetTime : TIME := T#18H;     (* Sunset time set to 6 PM *)\n    NoonTime : TIME := T#12H;       (* Noon time set to 12 PM *)\n    MorningAngle : REAL := 30.0;     (* Angle during morning *)\n    NoonAngle : REAL := 60.0;        (* Angle during noon *)\n    EveningAngle : REAL := 30.0;      (* Angle during evening *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the panel adjusts to the correct angle based on the time of day.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.CurrentTime < instance.SunriseTime OR instance.CurrentTime >= instance.SunsetTime) AND instance.PanelAngle = 0.0 OR (instance.CurrentTime >= instance.SunriseTime AND instance.CurrentTime < instance.NoonTime AND instance.PanelAngle = instance.MorningAngle) OR (instance.CurrentTime >= instance.NoonTime AND instance.CurrentTime < instance.SunsetTime AND instance.PanelAngle = instance.EveningAngle)"
        },
        "pattern_description": "The panel angle {instance.PanelAngle} should be set correctly based on the current time of day."
      }
    },
    {
      "property_description": "Ensure that when solar intensity reaches or exceeds 90%, the panel adjusts to the noon angle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.SolarIntensity >= 90.0 AND instance.PanelAngle = instance.NoonAngle) OR (instance.SolarIntensity < 90.0 AND instance.PanelAngle <> instance.NoonAngle)"
        },
        "pattern_description": "The panel angle should be {instance.NoonAngle} when {instance.SolarIntensity} is above 90, otherwise the angle should be adjusted based on time."
      }
    },
    {
      "property_description": "Ensure that the panel angle is 0 degrees during night time.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT (instance.CurrentTime < T#6H OR instance.CurrentTime >= T#18H) OR instance.PanelAngle = 0.0"
        },
        "pattern_description": "{NOT (instance.CurrentTime < T#6H OR instance.CurrentTime >= T#18H) OR instance.PanelAngle = 0.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the panel angle is set to the morning angle during morning hours when solar intensity is low.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT (instance.CurrentTime >= T#6H AND instance.CurrentTime < T#12H AND instance.SolarIntensity < 90.0) OR instance.PanelAngle = 30.0"
        },
        "pattern_description": "{NOT (instance.CurrentTime >= T#6H AND instance.CurrentTime < T#12H AND instance.SolarIntensity < 90.0) OR instance.PanelAngle = 30.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the panel angle is set to the evening angle during afternoon hours when solar intensity is low.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT (instance.CurrentTime >= T#12H AND instance.CurrentTime < T#18H AND instance.SolarIntensity < 90.0) OR instance.PanelAngle = 30.0"
        },
        "pattern_description": "{NOT (instance.CurrentTime >= T#12H AND instance.CurrentTime < T#18H AND instance.SolarIntensity < 90.0) OR instance.PanelAngle = 30.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the panel angle is set to the noon angle when solar intensity is high.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT (instance.SolarIntensity >= 90.0) OR instance.PanelAngle = 60.0"
        },
        "pattern_description": "{NOT (instance.SolarIntensity >= 90.0) OR instance.PanelAngle = 60.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the panel angle is always within a valid range.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.PanelAngle >= 0.0 AND instance.PanelAngle <= 90.0"
        },
        "pattern_description": "{instance.PanelAngle >= 0.0 AND instance.PanelAngle <= 90.0} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-17"
}
{
  "instruction": "Develop a PLC function block in Structured Text (ST) for a wind turbine control system that optimizes energy generation by adjusting blade pitch and generator speed based on wind speed inputs. The function block should include two input variables: WindSpeedSensor (REAL) to measure wind speed and GeneratorSpeedSensor (REAL) to monitor generator speed. It must produce two output variables: BladePitch (INT) for controlling the blade pitch angle in degrees and GeneratorSpeed (REAL) for managing the generator speed in RPM. The logic should differentiate between three wind speed categories: low (<=3.0), moderate (>3.0 and <=5.0), and high (>5.0). For high wind speeds, set the blade pitch to 5 degrees and the generator speed to 1000 RPM. For moderate wind speeds, adjust the blade pitch to 0 degrees and the generator speed to 800 RPM. For low wind speeds, decrease the blade pitch to -5 degrees and set the generator speed to 500 RPM. Ensure that the output ST code adheres to the required syntax rules. Structure the function block as follows: \n\nFUNCTION_BLOCK WindTurbineControl\nVAR_INPUT\n    WindSpeedSensor : REAL; (* Input for measuring wind speed *)\n    GeneratorSpeedSensor : REAL; (* Input for measuring generator speed *)\nEND_VAR\n\nVAR_OUTPUT\n    BladePitch : INT; (* Output for blade pitch control (degrees) *)\n    GeneratorSpeed : REAL; (* Output for generator speed control (RPM) *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that blade pitch is set to 5 degrees for high wind speeds (>5.0).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WindSpeedSensor > 5.0",
          "1": "instance.BladePitch = 5"
        },
        "pattern_description": "If {instance.WindSpeedSensor > 5.0} is true at the end of the PLC cycle, then {instance.BladePitch = 5} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that generator speed is set to 1000 RPM for high wind speeds (>5.0).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WindSpeedSensor > 5.0",
          "1": "instance.GeneratorSpeed = 1000.0"
        },
        "pattern_description": "If {instance.WindSpeedSensor > 5.0} is true at the end of the PLC cycle, then {instance.GeneratorSpeed = 1000.0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that blade pitch is set to 0 degrees for moderate wind speeds (>3.0 and <=5.0).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WindSpeedSensor > 3.0 AND instance.WindSpeedSensor <= 5.0",
          "1": "instance.BladePitch = 0"
        },
        "pattern_description": "If {instance.WindSpeedSensor > 3.0 AND instance.WindSpeedSensor <= 5.0} is true at the end of the PLC cycle, then {instance.BladePitch = 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that generator speed is set to 800 RPM for moderate wind speeds (>3.0 and <=5.0).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WindSpeedSensor > 3.0 AND instance.WindSpeedSensor <= 5.0",
          "1": "instance.GeneratorSpeed = 800.0"
        },
        "pattern_description": "If {instance.WindSpeedSensor > 3.0 AND instance.WindSpeedSensor <= 5.0} is true at the end of the PLC cycle, then {instance.GeneratorSpeed = 800.0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that blade pitch is set to -5 degrees for low wind speeds (<=3.0).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WindSpeedSensor <= 3.0",
          "1": "instance.BladePitch = -5"
        },
        "pattern_description": "If {instance.WindSpeedSensor <= 3.0} is true at the end of the PLC cycle, then {instance.BladePitch = -5} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that generator speed is set to 500 RPM for low wind speeds (<=3.0).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WindSpeedSensor <= 3.0",
          "1": "instance.GeneratorSpeed = 500.0"
        },
        "pattern_description": "If {instance.WindSpeedSensor <= 3.0} is true at the end of the PLC cycle, then {instance.GeneratorSpeed = 500.0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that blade pitch is always within the range of -5 to 5 degrees.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.BladePitch >= -5 AND instance.BladePitch <= 5"
        },
        "pattern_description": "{instance.BladePitch >= -5 AND instance.BladePitch <= 5} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-18"
}
{
  "instruction": "Develop a PLC function block in Structured Text (ST) for an automated rock climbing wall system that dynamically adjusts routes and difficulty levels based on user input. The function block should include four input variables: UserWeightSensor (REAL) for measuring the user's weight, WallDifficultyLevel (INT) to set the initial difficulty level, WallHeight (REAL) for defining the wall's height, and RouteSelector (INT) for selecting a climbing route. It should have two output variables: ClimbingMotorSpeed (REAL) to control the motor speed of the climbing wall and WallLights (BOOL) to manage the wall lighting system. The logic must adjust the climbing motor speed to 1.0 for users weighing more than 60 kg and to 0.8 for users weighing 60 kg or less. The wall difficulty level is determined by the selected route, with levels set to 1, 2, or 3 for Route 1, Route 2, and Route 3 respectively. Furthermore, the wall lights should activate when the wall height exceeds 5.0 meters, and turn off if the height is less. Ensure that the output ST code adheres to syntactical correctness. Structure the function block as follows:\n\nFUNCTION_BLOCK RockClimbingWallControl\nVAR_INPUT\n    UserWeightSensor : REAL; (* Input for measuring the user's weight *)\n    WallDifficultyLevel : INT; (* Input for setting the wall's initial difficulty level *)\n    WallHeight : REAL; (* Input for setting the wall's height *)\n    RouteSelector : INT; (* Input for selecting a climbing route *)\nEND_VAR\nVAR_OUTPUT\n    ClimbingMotorSpeed : REAL; (* Output for controlling the climbing wall motor speed *)\n    WallLights : BOOL; (* Output for controlling wall lighting *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the climbing motor speed is set to 1.0 for users weighing more than 60 kg.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.UserWeightSensor > 60.0",
          "1": "instance.ClimbingMotorSpeed = 1.0"
        },
        "pattern_description": "If {instance.UserWeightSensor > 60.0} is true at the end of the PLC cycle, then {instance.ClimbingMotorSpeed = 1.0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the wall difficulty level is set to 1 when Route 1 is selected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.RouteSelector = 1",
          "1": "instance.WallDifficultyLevel = 1"
        },
        "pattern_description": "If {instance.RouteSelector = 1} is true at the end of the PLC cycle, then {instance.WallDifficultyLevel = 1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the wall difficulty level is set to 2 when Route 2 is selected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.RouteSelector = 2",
          "1": "instance.WallDifficultyLevel = 2"
        },
        "pattern_description": "If {instance.RouteSelector = 2} is true at the end of the PLC cycle, then {instance.WallDifficultyLevel = 2} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the wall difficulty level is set to 3 when Route 3 is selected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.RouteSelector = 3",
          "1": "instance.WallDifficultyLevel = 3"
        },
        "pattern_description": "If {instance.RouteSelector = 3} is true at the end of the PLC cycle, then {instance.WallDifficultyLevel = 3} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the wall lights are turned on for walls taller than 5.0 meters.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WallHeight > 5.0",
          "1": "instance.WallLights = TRUE"
        },
        "pattern_description": "If {instance.WallHeight > 5.0} is true at the end of the PLC cycle, then {instance.WallLights = TRUE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-19"
}
{
  "instruction": "Develop a PLC function block in Structured Text (ST) for a commercial fish tank monitoring system that regulates oxygen levels, water temperature, and feeding schedules. The function block should feature four input variables: OxygenLevel (REAL) for assessing the oxygen concentration in the tank, WaterTemperature (REAL) to measure the temperature of the water, FeedingTime (TIME) that denotes when to feed the fish, and CurrentTime (TIME) which represents the current system time. It should provide three output variables: OxygenValve (BOOL) to manage the oxygen supply, Heater (BOOL) for controlling the water heater, and Feeder (BOOL) to operate the fish feeder. The logic must ensure that the oxygen valve opens when the oxygen level drops below 5.0, the heater activates when the water temperature is below 25.0°C, and the feeder operates when the current time is equal to or surpasses the designated feeding time. Furthermore, the oxygen valve and heater should automatically close when their specific conditions are not satisfied, while the feeder should be disabled outside of the scheduled feeding time. The output ST code must conform to correct syntax. Structure the function block as follows: \n\nFUNCTION_BLOCK FishTankControl\nVAR_INPUT\n    OxygenLevel : REAL; (* Input for oxygen level in the tank *)\n    WaterTemperature : REAL; (* Input for water temperature *)\n    FeedingTime : TIME; (* Time for scheduled feeding *)\n    CurrentTime : TIME; (* Current system time *)\nEND_VAR\nVAR_OUTPUT\n    OxygenValve : BOOL; (* Output to control oxygen supply *)\n    Heater : BOOL; (* Output to control the heater *)\n    Feeder : BOOL; (* Output to control the fish feeder *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the oxygen valve is opened when the oxygen level is below 5.0.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.OxygenLevel < 5.0",
          "1": "instance.OxygenValve = TRUE"
        },
        "pattern_description": "If {instance.OxygenLevel < 5.0} is true at the end of the PLC cycle, then {instance.OxygenValve = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the oxygen valve is closed when the oxygen level is at or above 5.0.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.OxygenLevel >= 5.0",
          "1": "instance.OxygenValve = FALSE"
        },
        "pattern_description": "If {instance.OxygenLevel >= 5.0} is true at the end of the PLC cycle, then {instance.OxygenValve = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the heater is turned on when the water temperature is below 25.0°C.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WaterTemperature < 25.0",
          "1": "instance.Heater = TRUE"
        },
        "pattern_description": "If {instance.WaterTemperature < 25.0} is true at the end of the PLC cycle, then {instance.Heater = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the heater is turned off when the water temperature is at or above 25.0°C.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WaterTemperature >= 25.0",
          "1": "instance.Heater = FALSE"
        },
        "pattern_description": "If {instance.WaterTemperature >= 25.0} is true at the end of the PLC cycle, then {instance.Heater = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the feeder is activated when the current time reaches or exceeds the feeding time.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CurrentTime >= instance.FeedingTime",
          "1": "instance.Feeder = TRUE"
        },
        "pattern_description": "If {instance.CurrentTime >= instance.FeedingTime} is true at the end of the PLC cycle, then {instance.Feeder = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the feeder is deactivated when the current time is before the feeding time.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CurrentTime < instance.FeedingTime",
          "1": "instance.Feeder = FALSE"
        },
        "pattern_description": "If {instance.CurrentTime < instance.FeedingTime} is true at the end of the PLC cycle, then {instance.Feeder = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-20"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for controlling a motorized retractable roof in a sports stadium, responding to various weather conditions. The function block should have three input variables: RainSensor (BOOL) for detecting the presence of rain, WindSensor (BOOL) for detecting wind conditions, and TemperatureSensor (REAL) for measuring the temperature. It should have one output variable: RoofMotor (BOOL) for managing the operation of the roof motor. The system's logic must follow these rules: 1. If it is raining and windy, then the roof should close completely (RoofMotor = FALSE). 2. If it is raining but not windy, then the roof should be partially closed (RoofMotor = TRUE). 3. If it is not raining and the temperature is below 20.0°C, then the roof should close slightly (RoofMotor = TRUE). 4. If it is not raining and the temperature is 20.0°C or above, then the roof should be fully open (RoofMotor = FALSE). Ensure that the output ST code adheres to the correct syntax rules. The function block should be structured as follows: \n\nFUNCTION_BLOCK RetractableRoofControl\nVAR_INPUT\n    RainSensor : BOOL; (* Input to detect rain *)\n    WindSensor : BOOL; (* Input to detect wind *)\n    TemperatureSensor : REAL; (* Input to measure temperature *)\nEND_VAR\nVAR_OUTPUT\n    RoofMotor : BOOL; (* Output to control the roof motor *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the roof is completely closed when it's raining and windy.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.RainSensor = TRUE AND instance.WindSensor = TRUE",
          "1": "instance.RoofMotor = FALSE"
        },
        "pattern_description": "If {instance.RainSensor = TRUE AND instance.WindSensor = TRUE} is true at the end of the PLC cycle, then {instance.RoofMotor = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the roof is partially closed when it's raining but not windy.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.RainSensor = TRUE AND instance.WindSensor = FALSE",
          "1": "instance.RoofMotor = TRUE"
        },
        "pattern_description": "If {instance.RainSensor = TRUE AND instance.WindSensor = FALSE} is true at the end of the PLC cycle, then {instance.RoofMotor = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the roof is slightly closed when it's not raining and the temperature is below 20.0°C.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.RainSensor = FALSE AND instance.TemperatureSensor < 20.0",
          "1": "instance.RoofMotor = TRUE"
        },
        "pattern_description": "If {instance.RainSensor = FALSE AND instance.TemperatureSensor < 20.0} is true at the end of the PLC cycle, then {instance.RoofMotor = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the roof is completely open when it's not raining and the temperature is 20.0°C or above.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.RainSensor = FALSE AND instance.TemperatureSensor >= 20.0",
          "1": "instance.RoofMotor = FALSE"
        },
        "pattern_description": "If {instance.RainSensor = FALSE AND instance.TemperatureSensor >= 20.0} is true at the end of the PLC cycle, then {instance.RoofMotor = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-21"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for an automatic sandwich making machine, assembling sandwiches based on customer selections. The function block should have six inputs: BreadFeeder (BOOL) to detect the presence of bread slices, and five ingredient/condiment inputs (Ingredient1, Ingredient2, Ingredient3, Condiment1, Condiment2, all BOOL) to detect the presence of specific ingredients and condiments. It should have two outputs: ConveyorMotor (BOOL) to control the conveyor belt motor, and AssembleMotor (BOOL) to control the sandwich assembly motor. The system should operate as follows: 1. When bread is detected (BreadFeeder is TRUE), activate the conveyor motor and increment the slice count. 2. When at least two bread slices are detected (SliceCount >= 2) and all ingredients and condiments are present, activate the assembly motor. 3. If any ingredient or condiment is missing, or there aren't enough bread slices, stop the assembly motor. 4. Stop the conveyor motor when no bread is detected. Implement this logic in the function block, ensuring proper control of the sandwich making process based on the presence of ingredients and bread slices.Please ensure that the output ST code complies with the syntax rules.The function block should use the following structure:\n\nFUNCTION_BLOCK SandwichMaker\nVAR_INPUT\n    BreadFeeder : BOOL; (* Input: Detects the presence of bread slices *)\n    Ingredient1 : BOOL; (* Input: Detects the presence of Ingredient 1 (e.g., cheese) *)\n    Ingredient2 : BOOL; (* Input: Detects the presence of Ingredient 2 (e.g., lettuce) *)\n    Ingredient3 : BOOL; (* Input: Detects the presence of Ingredient 3 (e.g., tomatoes) *)\n    Condiment1 : BOOL; (* Input: Detects the presence of Condiment 1 (e.g., mayo) *)\n    Condiment2 : BOOL; (* Input: Detects the presence of Condiment 2 (e.g., mustard) *)\nEND_VAR\nVAR_OUTPUT\n    ConveyorMotor : BOOL; (* Output: Controls the conveyor belt motor *)\n    AssembleMotor : BOOL; (* Output: Controls the sandwich assembly motor *)\nEND_VAR\nVAR\n    SliceCount : INT := 0; (* Counter for bread slices *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the conveyor motor is activated when bread is detected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.BreadFeeder = TRUE",
          "1": "instance.ConveyorMotor = TRUE"
        },
        "pattern_description": "If {instance.BreadFeeder = TRUE} is true at the end of the PLC cycle, then {instance.ConveyorMotor = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the conveyor motor is deactivated when no bread is detected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.BreadFeeder = FALSE",
          "1": "instance.ConveyorMotor = FALSE"
        },
        "pattern_description": "If {instance.BreadFeeder = FALSE} is true at the end of the PLC cycle, then {instance.ConveyorMotor = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the assembly motor is deactivated when any ingredient or condiment is missing.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.Ingredient1 = FALSE OR instance.Ingredient2 = FALSE OR instance.Ingredient3 = FALSE OR instance.Condiment1 = FALSE OR instance.Condiment2 = FALSE",
          "1": "instance.AssembleMotor = FALSE"
        },
        "pattern_description": "If {instance.Ingredient1 = FALSE OR instance.Ingredient2 = FALSE OR instance.Ingredient3 = FALSE OR instance.Condiment1 = FALSE OR instance.Condiment2 = FALSE} is true at the end of the PLC cycle, then {instance.AssembleMotor = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-22"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for a drone charging and management station that handles the recharging and deployment of multiple drones. The function block should have four input variables: Drone1BatteryLevel, Drone2BatteryLevel, and Drone3BatteryLevel (all INT) representing the battery levels of three drones (ranging from 0 to 100%), and ChargingTime (TIME) specifying the required charging duration. It should have five output variables: Drone1Status, Drone2Status, and Drone3Status (all BOOL) indicating the charging status of each drone, ChargingStationStatus (BOOL) indicating if the charging station is currently in use, and DroneDeployed (BOOL) to signify if a drone is currently deployed. The functionality must operate as follows: 1. If the charging station is not in use, the system should check the battery levels of the drones and activate charging for the first drone whose battery level is below 20%. 2. When a drone starts charging, update the charging station status to indicate it's in use. 3. If the charging time reaches zero, deactivate all drone statuses and set the charging station to not in use. 4. When a drone is deployed, if any drone's battery level falls below 10%, update the deployed status to false to recall the drone. Implement this logic in the function block, ensuring efficient management of the drone charging and deployment processes based on battery levels and charging status. Please ensure that the output ST code follows all required syntax rules. Structure the function block as follows:\n\nFUNCTION_BLOCK DroneChargingStation\nVAR_INPUT\n    Drone1BatteryLevel : INT := 0; (* Battery level of Drone 1 (0-100%) *)\n    Drone2BatteryLevel : INT := 0; (* Battery level of Drone 2 (0-100%) *)\n    Drone3BatteryLevel : INT := 0; (* Battery level of Drone 3 (0-100%) *)\n    ChargingTime : TIME := T#30s; (* Charging time required for each drone *)\nEND_VAR\nVAR_OUTPUT\n    Drone1Status : BOOL := FALSE; (* Status of Drone 1 *)\n    Drone2Status : BOOL := FALSE; (* Status of Drone 2 *)\n    Drone3Status : BOOL := FALSE; (* Status of Drone 3 *)\n    ChargingStationStatus : BOOL := FALSE; (* Charging station status *)\n    DroneDeployed : BOOL := FALSE; (* Indicates if a drone is deployed *)\nEND_VAR\nVAR\n    TimeRemaining : TIME := ChargingTime; (* Remaining charging time for the current charging operation *)\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that all drone statuses are deactivated and the charging station is set to not in use when the charging time reaches zero and the charging station was previously in use.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-betweencycles",
        "pattern_params": {
          "0": "instance.ChargingTime > T#0s AND instance.ChargingStationStatus = TRUE",
          "1": "instance.ChargingTime = T#0s",
          "2": "instance.Drone1Status = FALSE AND instance.Drone2Status = FALSE AND instance.Drone3Status = FALSE AND instance.ChargingStationStatus = FALSE"
        },
        "pattern_description": "If {instance.ChargingTime > T#0s AND instance.ChargingStationStatus = TRUE} is true at the end of cycle N and {instance.ChargingTime = T#0s} is true at the end of cycle N+1, then {instance.Drone1Status = FALSE AND instance.Drone2Status = FALSE AND instance.Drone3Status = FALSE AND instance.ChargingStationStatus = FALSE} is always true at the end of cycle N+1."
      }
    },
    {
      "property_description": "Ensure that the deployed status is set to false when any drone's battery level falls below 10%.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "(instance.Drone1BatteryLevel < 10 OR instance.Drone2BatteryLevel < 10 OR instance.Drone3BatteryLevel < 10) AND instance.DroneDeployed = TRUE",
          "1": "instance.DroneDeployed = FALSE"
        },
        "pattern_description": "If {(instance.Drone1BatteryLevel < 10 OR instance.Drone2BatteryLevel < 10 OR instance.Drone3BatteryLevel < 10) AND instance.DroneDeployed = TRUE} is true at the end of the PLC cycle, then {instance.DroneDeployed = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-23"
}
{
  "instruction": "Design a FUNCTION_BLOCK in Structured Text (ST) for an automated smoothie maker that prepares smoothies based on customer preferences and available ingredients. The system should manage four types of ingredients: Banana, Berry Mix, Spinach, and Yogurt. It should accept customer preferences as an integer input (1, 2, or 3). The function block must check the availability of the required ingredients before starting the blending process. It should control a blender motor and an ingredient dispenser based on the selected recipe and the availability of ingredients. The function block must implement three smoothie recipes: Recipe 1, which includes Banana, Berry Mix, and Yogurt; Recipe 2, which comprises Berry Mix, Spinach, and Yogurt; and Recipe 3, which contains Banana, Spinach, and Yogurt. Additionally, the system must ensure that the blender motor and dispenser are turned off for invalid preferences or when any of the required ingredients are unavailable. Use boolean outputs to control the operation of the blender motor and ingredient dispenser. Please ensure that the output ST code adheres to proper syntax rules. The function block should be structured as follows: \n\nFUNCTION_BLOCK AutomatedSmoothieMaker\nVAR_INPUT\n    BananaAvailable : BOOL;\n    BerryMixAvailable : BOOL;\n    SpinachAvailable : BOOL;\n    YogurtAvailable : BOOL;\n    CustomerPreference : INT;\nEND_VAR\n\nVAR_OUTPUT\n    BlenderMotor : BOOL;\n    Dispenser : BOOL;\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the blender motor and dispenser are activated when all required ingredients for recipe 1 are available.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CustomerPreference = 1 AND instance.BananaAvailable = TRUE AND instance.BerryMixAvailable = TRUE AND instance.YogurtAvailable = TRUE",
          "1": "instance.BlenderMotor = TRUE AND instance.Dispenser = TRUE"
        },
        "pattern_description": "If {instance.CustomerPreference = 1 AND instance.BananaAvailable = TRUE AND instance.BerryMixAvailable = TRUE AND instance.YogurtAvailable = TRUE} is true at the end of the PLC cycle, then {instance.BlenderMotor = TRUE AND instance.Dispenser = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the blender motor and dispenser are activated when all required ingredients for recipe 2 are available.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CustomerPreference = 2 AND instance.BerryMixAvailable = TRUE AND instance.SpinachAvailable = TRUE AND instance.YogurtAvailable = TRUE",
          "1": "instance.BlenderMotor = TRUE AND instance.Dispenser = TRUE"
        },
        "pattern_description": "If {instance.CustomerPreference = 2 AND instance.BerryMixAvailable = TRUE AND instance.SpinachAvailable = TRUE AND instance.YogurtAvailable = TRUE} is true at the end of the PLC cycle, then {instance.BlenderMotor = TRUE AND instance.Dispenser = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the blender motor and dispenser are activated when all required ingredients for recipe 3 are available.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CustomerPreference = 3 AND instance.BananaAvailable = TRUE AND instance.SpinachAvailable = TRUE AND instance.YogurtAvailable = TRUE",
          "1": "instance.BlenderMotor = TRUE AND instance.Dispenser = TRUE"
        },
        "pattern_description": "If {instance.CustomerPreference = 3 AND instance.BananaAvailable = TRUE AND instance.SpinachAvailable = TRUE AND instance.YogurtAvailable = TRUE} is true at the end of the PLC cycle, then {instance.BlenderMotor = TRUE AND instance.Dispenser = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the blender motor and dispenser are deactivated when an invalid recipe is selected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CustomerPreference < 1 OR instance.CustomerPreference > 3",
          "1": "instance.BlenderMotor = FALSE AND instance.Dispenser = FALSE"
        },
        "pattern_description": "If {instance.CustomerPreference < 1 OR instance.CustomerPreference > 3} is true at the end of the PLC cycle, then {instance.BlenderMotor = FALSE AND instance.Dispenser = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the blender motor and dispenser are deactivated when required ingredients for the selected recipe are unavailable.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "(instance.CustomerPreference = 1 AND (NOT instance.BananaAvailable OR NOT instance.BerryMixAvailable OR NOT instance.YogurtAvailable)) OR (instance.CustomerPreference = 2 AND (NOT instance.BerryMixAvailable OR NOT instance.SpinachAvailable OR NOT instance.YogurtAvailable)) OR (instance.CustomerPreference = 3 AND (NOT instance.BananaAvailable OR NOT instance.SpinachAvailable OR NOT instance.YogurtAvailable))",
          "1": "instance.BlenderMotor = FALSE AND instance.Dispenser = FALSE"
        },
        "pattern_description": "If {(instance.CustomerPreference = 1 AND (NOT instance.BananaAvailable OR NOT instance.BerryMixAvailable OR NOT instance.YogurtAvailable)) OR (instance.CustomerPreference = 2 AND (NOT instance.BerryMixAvailable OR NOT instance.SpinachAvailable OR NOT instance.YogurtAvailable)) OR (instance.CustomerPreference = 3 AND (NOT instance.BananaAvailable OR NOT instance.SpinachAvailable OR NOT instance.YogurtAvailable))} is true at the end of the PLC cycle, then {instance.BlenderMotor = FALSE AND instance.Dispenser = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-24"
}
{
  "instruction": "Develop a function block in Structured Text (ST) for a precision metal engraving machine that manages engraving depth and speed based on selected design configurations. The machine should take an integer input for design selection, adjusting the engraving parameters accordingly, and control the motors that manage the Z-axis and the engraving operation. Ensure that for designs 1, 2, and 3, the engraving depths and speeds are set as follows: for Design 1, set the engraving speed to 10.0 and depth to 0.1; for Design 2, set the engraving speed to 8.0 and depth to 0.2; for Design 3, set the engraving speed to 12.0 and depth to 0.15. If an invalid design is selected, the motors should be disabled, and the engraving parameters should be set to zero. The function block must ensure that the Z-axis motor and engraving motor are activated when a valid design is selected, and both should be deactivated when an invalid design is chosen. Additionally, incorporate conditions to verify that this operation is repeatable under design changes. The function block should be structured as follows:\n\nFUNCTION_BLOCK PrecisionEngravingMachine\nVAR_INPUT\n    DesignSelection : INT;\n    EngravingDepth : REAL;\n    EngravingSpeed : REAL;\nEND_VAR\n\nVAR_OUTPUT\n    ZAxisMotor : BOOL;\n    EngravingMotor : BOOL;\nEND_VAR\n\nVAR\n    CalculatedDepth : REAL;\n    CalculatedSpeed : REAL;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the Z-axis motor and engraving motor are activated when a valid design (1, 2, or 3) is selected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DesignSelection >= 1 AND instance.DesignSelection <= 3",
          "1": "instance.ZAxisMotor = TRUE AND instance.EngravingMotor = TRUE"
        },
        "pattern_description": "If {instance.DesignSelection >= 1 AND instance.DesignSelection <= 3} is true at the end of the PLC cycle, then {instance.ZAxisMotor = TRUE AND instance.EngravingMotor = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the Z-axis motor and engraving motor are deactivated when an invalid design is selected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DesignSelection < 1 OR instance.DesignSelection > 3",
          "1": "instance.ZAxisMotor = FALSE AND instance.EngravingMotor = FALSE"
        },
        "pattern_description": "If {instance.DesignSelection < 1 OR instance.DesignSelection > 3} is true at the end of the PLC cycle, then {instance.ZAxisMotor = FALSE AND instance.EngravingMotor = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the engraving speed is set correctly for Design 1.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DesignSelection = 1",
          "1": "instance.EngravingSpeed = 10.0"
        },
        "pattern_description": "If {instance.DesignSelection = 1} is true at the end of the PLC cycle, then {instance.EngravingSpeed = 10.0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the engraving speed is set correctly for Design 2.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DesignSelection = 2",
          "1": "instance.EngravingSpeed = 8.0"
        },
        "pattern_description": "If {instance.DesignSelection = 2} is true at the end of the PLC cycle, then {instance.EngravingSpeed = 8.0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure system states are repeatable under design changes.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-repeatability",
        "pattern_params": {
          "1": "instance.ZAxisMotor = TRUE AND instance.EngravingMotor = TRUE"
        },
        "pattern_description": "Any time it is possible to have {instance.ZAxisMotor = TRUE AND instance.EngravingMotor = TRUE} at the end of a cycle."
      }
    }
  ],
  "id": "v2-M-25"
}
{
  "instruction": "Develop a FUNCTION_BLOCK in Structured Text (ST) for an automatic window cleaning system designed for high-rise buildings. The system should initiate the cleaning process when the start button is pressed, provided that the cleaning operation is not currently in progress. It should move the cleaning elevator upward until it reaches the designated upper limit. At this point, the system must activate both the cleaning brush (RotateClockwise) and the water pump. While cleaning, the elevator should descend automatically. The process should cease when the elevator reaches the lower limit. An emergency stop feature must be included to immediately halt all operations if activated, ensuring safety at all times. The design should guarantee that conflicting actions, such as moving the elevator up and down simultaneously, are prohibited. Use flags to monitor the state of the system, such as whether cleaning is in progress or if the elevator is moving. The function block must also consider constant values for various system parameters, such as the cleaning speed if applicable. Please ensure that the output ST code adheres to the appropriate syntax rules. The function block should be structured as follows: \n\nFUNCTION_BLOCK WindowCleaningSystem\nVAR_INPUT\n    StartButton : BOOL;\n    EmergencyStop : BOOL;\n    UpperLimit : BOOL;\n    LowerLimit : BOOL;\nEND_VAR\n\nVAR_OUTPUT\n    ElevatorUp : BOOL;\n    ElevatorDown : BOOL;\n    RotateClockwise : BOOL;\n    WaterPump : BOOL;\nEND_VAR\n\nVAR\n    CleaningInProgress : BOOL;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the cleaning brush and water pump activate when the elevator reaches the upper limit.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.UpperLimit AND instance.ElevatorUp AND NOT instance.EmergencyStop",
          "1": "instance.RotateClockwise AND instance.WaterPump AND instance.ElevatorDown"
        },
        "pattern_description": "If {instance.UpperLimit AND instance.ElevatorUp AND NOT instance.EmergencyStop} is true at the end of the PLC cycle, then {instance.RotateClockwise AND instance.WaterPump AND instance.ElevatorDown} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that all operations stop when the emergency stop is activated.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EmergencyStop",
          "1": "NOT instance.ElevatorUp AND NOT instance.ElevatorDown AND NOT instance.RotateClockwise AND NOT instance.WaterPump"
        },
        "pattern_description": "If {instance.EmergencyStop} is true at the end of the PLC cycle, then {NOT instance.ElevatorUp AND NOT instance.ElevatorDown AND NOT instance.RotateClockwise AND NOT instance.WaterPump} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the elevator cannot move up and down simultaneously.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "0": "instance.ElevatorUp AND instance.ElevatorDown"
        },
        "pattern_description": "{instance.ElevatorUp AND instance.ElevatorDown} is impossible at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-26"
}
{
  "instruction": "Create a PLC function block in Structured Text (ST) for controlling an electric vehicle (EV) charging station named 'ChargingStationControl'. The function block should have inputs for EV connection status (EVConnected : BOOL), battery voltage (EVVoltage : REAL), charging current (EVCurrent : REAL), state of charge (EVStateOfCharge : REAL), charging time (ChargingTimer : TIME), and predefined constants (MinimumVoltage, MaximumCurrent, MinimumSOC, ChargingVoltage, ChargingCurrent : REAL, MaximumChargingTime : TIME). It should control an output to start or stop EV charging (EVCharging : BOOL). Implement the following control logic:\n\nStart charging (EVCharging := TRUE) only when all these conditions are met:\n- An EV is connected (EVConnected = TRUE)\n- EV voltage is above the minimum (EVVoltage > MinimumVoltage)\n- EV current is at or below the maximum (EVCurrent <= MaximumCurrent)\n- EV is not fully charged (EVStateOfCharge < 100.0)\n- Charging time has not exceeded the maximum (ChargingTimer <= MaximumChargingTime)\n\nStop charging (EVCharging := FALSE) if any of these conditions occur:\n- EV is disconnected (EVConnected = FALSE)\n- EV voltage falls below the minimum (EVVoltage <= MinimumVoltage)\n- EV current exceeds the maximum (EVCurrent > MaximumCurrent)\n- EV is fully charged (EVStateOfCharge >= 100.0)\n- Maximum charging time is exceeded (ChargingTimer > MaximumChargingTime)\n\nEnsure that the charging status is updated based on these conditions at the end of each PLC cycle. Please ensure that the output ST code complies with the syntax rules.The function block should use the following structure:\n\nFUNCTION_BLOCK ChargingStationControl\nVAR_INPUT\n    EVConnected : BOOL;\n    EVVoltage : REAL;\n    EVCurrent : REAL;\n    EVStateOfCharge : REAL;\n    ChargingTimer : TIME;\n    MinimumVoltage : REAL;\n    MaximumCurrent : REAL;\n    MinimumSOC : REAL;\n    ChargingVoltage : REAL;\n    ChargingCurrent : REAL;\n    MaximumChargingTime : TIME;\nEND_VAR\n\nVAR_OUTPUT\n    EVCharging : BOOL;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that charging starts only when an EV is connected and meets all charging conditions.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EVConnected = TRUE AND instance.EVVoltage > instance.MinimumVoltage AND instance.EVCurrent <= instance.MaximumCurrent AND instance.EVStateOfCharge < 100.0 AND instance.ChargingTimer <= instance.MaximumChargingTime",
          "1": "instance.EVCharging = TRUE"
        },
        "pattern_description": "If {instance.EVConnected = TRUE AND instance.EVVoltage > instance.MinimumVoltage AND instance.EVCurrent <= instance.MaximumCurrent AND instance.EVStateOfCharge < 100.0 AND instance.ChargingTimer <= instance.MaximumChargingTime} is true at the end of the PLC cycle, then {instance.EVCharging = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that charging stops if the maximum charging time is exceeded.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ChargingTimer > instance.MaximumChargingTime",
          "1": "instance.EVCharging = FALSE"
        },
        "pattern_description": "If {instance.ChargingTimer > instance.MaximumChargingTime} is true at the end of the PLC cycle, then {instance.EVCharging = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that charging stops if the EV is disconnected.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EVConnected = FALSE",
          "1": "instance.EVCharging = FALSE"
        },
        "pattern_description": "If {instance.EVConnected = FALSE} is true at the end of the PLC cycle, then {instance.EVCharging = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that charging stops if the EV voltage falls below the minimum threshold.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EVVoltage <= instance.MinimumVoltage",
          "1": "instance.EVCharging = FALSE"
        },
        "pattern_description": "If {instance.EVVoltage <= instance.MinimumVoltage} is true at the end of the PLC cycle, then {instance.EVCharging = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that charging stops if the EV current exceeds the maximum threshold.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EVCurrent > instance.MaximumCurrent",
          "1": "instance.EVCharging = FALSE"
        },
        "pattern_description": "If {instance.EVCurrent > instance.MaximumCurrent} is true at the end of the PLC cycle, then {instance.EVCharging = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that charging stops if the EV is fully charged.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EVStateOfCharge >= 100.0",
          "1": "instance.EVCharging = FALSE"
        },
        "pattern_description": "If {instance.EVStateOfCharge >= 100.0} is true at the end of the PLC cycle, then {instance.EVCharging = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-27"
}
{
  "instruction": "Develop a PLC function block (FUNCTION_BLOCK) for controlling a smart HVAC system. The system needs to monitor temperature and humidity sensor inputs and sanitize these inputs to ensure they are within valid ranges. Based on the sanitized inputs, the system needs to determine whether heating, cooling, or ventilation is required, prioritizing heating and cooling needs. When multiple needs are present, heating and cooling should be prioritized. The system should control the HVAC operating mode and fan speed to ensure efficient operation and maintain the desired temperature and humidity settings. The specific requirements are as follows:\nMonitor temperature and humidity sensor inputs.\nSanitize the sensor inputs to ensure they are within valid ranges.\nDetermine system requirements for heating, cooling, and ventilation based on the sanitized inputs.\nPrioritize heating and cooling needs when multiple requirements are present.\nControl the HVAC operating mode and fan speed based on the determined requirements.\nEnsure the HVAC system operates efficiently and maintains the desired temperature and humidity settings.\nInputs:\nTemperature sensor reading (TemperatureSensor: REAL)\nHumidity sensor reading (HumiditySensor: REAL)\nOutputs:\nHVAC operating mode (HVACMode: INT, 0=Off, 1=Cooling, 2=Heating, 3=Ventilation)\nFan speed (HVACFanSpeed: INT, 0=Off, 1=Low, 2=Medium, 3=High)\nInternal Variables:\nDesired temperature (DesiredTemperature: REAL, default: 24.0)\nDesired humidity (DesiredHumidity: REAL, default: 50.0)\nTemperature threshold (TemperatureThreshold: REAL, default: 1.0)\nHumidity threshold (HumidityThreshold: REAL, default: 5.0)\nSanitized humidity input (AdjustedHumidity: REAL)\nSanitized temperature input (AdjustedTemperature: REAL)\nVentilation requirement flag (NeedsVentilation: BOOL)\nHeating requirement flag (NeedsHeating: BOOL)\nCooling requirement flag (NeedsCooling: BOOL)\nControl Logic:\nInput Sanitization:\nIf the humidity sensor reading is less than 0.0, set the sanitized humidity to 0.0.\nIf the humidity sensor reading is greater than 100.0, set the sanitized humidity to 100.0.\nOtherwise, set the sanitized humidity to the humidity sensor reading.\nIf the temperature sensor reading is less than -50.0, set the sanitized temperature to -50.0.\nIf the temperature sensor reading is greater than 100.0, set the sanitized temperature to 100.0.\nOtherwise, set the sanitized temperature to the temperature sensor reading.\nDetermine System Requirements:\nIf the sanitized humidity is less than the desired humidity minus the humidity threshold, set the ventilation requirement flag to TRUE.\nIf the sanitized temperature is less than the desired temperature minus the temperature threshold, set the heating requirement flag to TRUE.\nIf the sanitized temperature is greater than the desired temperature plus the temperature threshold, set the cooling requirement flag to TRUE.\nControl Logic:\nIf the heating requirement flag is TRUE, set the HVAC operating mode to 2 and the fan speed to 3.\nOtherwise, if the cooling requirement flag is TRUE, set the HVAC operating mode to 1 and the fan speed to 3.\nOtherwise, if the ventilation requirement flag is TRUE, set the HVAC operating mode to 3 and the fan speed to 3.\nOtherwise, set the HVAC operating mode to 0 and the fan speed to 0.\nFUNCTION_BLOCK SmartHVACSystem\nVAR_INPUT\n TemperatureSensor : REAL; (* Temperature sensor reading *)\n HumiditySensor : REAL; (* Humidity sensor reading *)\nEND_VAR\nVAR_OUTPUT\n HVACMode : INT := 0; (* HVAC operating mode: 0=Off, 1=Cooling, 2=Heating, 3=Ventilation *)\n HVACFanSpeed : INT := 0; (* Fan speed: 0=Off, 1=Low, 2=Medium, 3=High *)\nEND_VAR\nVAR\n DesiredTemperature : REAL := 24.0; (* Desired temperature setting *)\n DesiredHumidity : REAL := 50.0; (* Desired humidity setting *)\n TemperatureThreshold : REAL := 1.0; (* Temperature tolerance threshold *)\n HumidityThreshold : REAL := 5.0; (* Humidity tolerance threshold *)\n AdjustedHumidity : REAL; (* Sanitized humidity input *)\n AdjustedTemperature : REAL; (* Sanitized temperature input *)\n NeedsVentilation : BOOL; (* Flag for ventilation requirement *)\n NeedsHeating : BOOL; (* Flag for heating requirement *)\n NeedsCooling : BOOL; (* Flag for cooling requirement *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "HVAC mode must be heating when temperature is too low",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor < instance.DesiredTemperature - instance.TemperatureThreshold",
          "1": "instance.HVACMode = 2"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "If {instance.TemperatureSensor < instance.DesiredTemperature - instance.TemperatureThreshold} is true at the end of the PLC cycle, then {instance.HVACMode = 2} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "HVAC mode must be cooling when temperature is too high",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor > instance.DesiredTemperature + instance.TemperatureThreshold",
          "1": "instance.HVACMode = 1"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "If {instance.TemperatureSensor > instance.DesiredTemperature + instance.TemperatureThreshold} is true at the end of the PLC cycle, then {instance.HVACMode = 1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "HVAC mode range check",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.HVACMode >= 0 AND instance.HVACMode <= 3"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "{instance.HVACMode >= 0 AND instance.HVACMode <= 3} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Fan speed must match HVAC mode",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.HVACMode > 0",
          "1": "instance.HVACFanSpeed = 3"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "If {instance.HVACMode > 0} is true at the end of the PLC cycle, then {instance.HVACFanSpeed = 3} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Adjusted humidity must be within valid range",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.AdjustedHumidity >= 0.0 AND instance.AdjustedHumidity <= 100.0"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "{instance.AdjustedHumidity >= 0.0 AND instance.AdjustedHumidity <= 100.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Fan must be off when HVAC is off",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.HVACMode = 0",
          "1": "instance.HVACFanSpeed = 0"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "If {instance.HVACMode = 0} is true at the end of the PLC cycle, then {instance.HVACFanSpeed = 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "HVAC must be in heating mode when NeedsHeating is true",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.NeedsHeating = TRUE",
          "1": "instance.HVACMode = 2"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "If {instance.NeedsHeating = TRUE} is true at the end of the PLC cycle, then {instance.HVACMode = 2} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "HVAC must be in cooling mode when NeedsCooling is true and NeedsHeating is false",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.NeedsCooling = TRUE AND instance.NeedsHeating = FALSE",
          "1": "instance.HVACMode = 1"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "If {instance.NeedsCooling = TRUE AND instance.NeedsHeating = FALSE} is true at the end of the PLC cycle, then {instance.HVACMode = 1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "HVAC must be in ventilation mode when only NeedsVentilation is true",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.NeedsVentilation = TRUE AND instance.NeedsHeating = FALSE AND instance.NeedsCooling = FALSE",
          "1": "instance.HVACMode = 3"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "If {instance.NeedsVentilation = TRUE AND instance.NeedsHeating = FALSE AND instance.NeedsCooling = FALSE} is true at the end of the PLC cycle, then {instance.HVACMode = 3} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "HVAC must be off when no needs are present",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.NeedsVentilation = FALSE AND instance.NeedsHeating = FALSE AND instance.NeedsCooling = FALSE",
          "1": "instance.HVACMode = 0"
        },
        "entry_point": "SmartHVACSystem",
        "pattern_description": "If {instance.NeedsVentilation = FALSE AND instance.NeedsHeating = FALSE AND instance.NeedsCooling = FALSE} is true at the end of the PLC cycle, then {instance.HVACMode = 0} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-28"
}

{
  "instruction": "Develop a PLC program in Structured Text (ST) to control a multi-level car parking system. The program should manage up to 100 parking slots and control two elevators for efficient slot allocation and car transportation. It should detect car arrivals at specific slots, assign an appropriate elevator based on the slot location (slots 1–50 for Elevator 1 and slots 51–100 for Elevator 2), and ensure the elevators move towards their assigned targets. The system must track the current and target positions of each elevator and update their status (busy or idle) as they complete tasks. Idle elevators should scan for new car arrivals and handle tasks as they arise.\nFUNCTION_BLOCK CarParkingSystem\nVAR_INPUT\n NewCarSlot : INT; (* Input for new car arrival slot number *)\nEND_VAR\nVAR_OUTPUT\n Elevator1Busy : BOOL; (* Elevator 1 status - busy or idle *)\n Elevator2Busy : BOOL; (* Elevator 2 status - busy or idle *)\n Elevator1Position : INT; (* Elevator 1 current position *)\n Elevator2Position : INT; (* Elevator 2 current position *)\nEND_VAR\nVAR\n Elevator1Target : INT; (* Elevator 1 target floor *)\n Elevator2Target : INT; (* Elevator 2 target floor *)\n CarSlots : ARRAY[1..100] OF BOOL; (* Array to represent parking slots - TRUE if occupied *)\n CurrentSlot : INT; (* Loop counter for scanning slots *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Elevators must not operate simultaneously",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.Elevator1Busy = TRUE AND instance.Elevator2Busy = TRUE"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "{instance.Elevator1Busy = TRUE AND instance.Elevator2Busy = TRUE} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Elevator 1 position must be within its valid range",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.Elevator1Position >= 0 AND instance.Elevator1Position <= 50"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "{instance.Elevator1Position >= 0 AND instance.Elevator1Position <= 50} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Elevator 2 position must be within its valid range",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.Elevator2Position >= 51 AND instance.Elevator2Position <= 100"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "{instance.Elevator2Position >= 51 AND instance.Elevator2Position <= 100} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Elevator 1 must be idle when reaching its target position",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.Elevator1Position = instance.Elevator1Target",
          "1": "instance.Elevator1Busy = FALSE"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "If {instance.Elevator1Position = instance.Elevator1Target} is true at the end of the PLC cycle, then {instance.Elevator1Busy = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Elevator 2 must be idle when reaching its target position",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.Elevator2Position = instance.Elevator2Target",
          "1": "instance.Elevator2Busy = FALSE"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "If {instance.Elevator2Position = instance.Elevator2Target} is true at the end of the PLC cycle, then {instance.Elevator2Busy = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Elevators must not be assigned to the same parking slot",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.Elevator1Target = instance.Elevator2Target AND instance.Elevator1Target > 0"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "{instance.Elevator1Target = instance.Elevator2Target AND instance.Elevator1Target > 0} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Elevator 1 target must be within its service range",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.Elevator1Target = 0 OR (instance.Elevator1Target >= 1 AND instance.Elevator1Target <= 50)"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "{instance.Elevator1Target = 0 OR (instance.Elevator1Target >= 1 AND instance.Elevator1Target <= 50)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Elevator 2 target must be within its service range",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.Elevator2Target = 0 OR (instance.Elevator2Target >= 51 AND instance.Elevator2Target <= 100)"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "{instance.Elevator2Target = 0 OR (instance.Elevator2Target >= 51 AND instance.Elevator2Target <= 100)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Busy elevator must have valid target position",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.Elevator1Busy = TRUE OR instance.Elevator2Busy = TRUE",
          "1": "instance.Elevator1Target > 0 OR instance.Elevator2Target > 0"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "If {instance.Elevator1Busy = TRUE OR instance.Elevator2Busy = TRUE} is true at the end of the PLC cycle, then {instance.Elevator1Target > 0 OR instance.Elevator2Target > 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Elevator positions must change by exactly one unit when moving",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT instance.Elevator1Busy OR (instance.Elevator1Position = instance.Elevator1Position + 1 OR instance.Elevator1Position = instance.Elevator1Position - 1)"
        },
        "entry_point": "CarParkingSystem",
        "pattern_description": "{NOT instance.Elevator1Busy OR (instance.Elevator1Position = instance.Elevator1Position + 1 OR instance.Elevator1Position = instance.Elevator1Position - 1)} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-29"
}
{
  "instruction": "Develop a FUNCTION_BLOCK in Structured Text (ST) for an automatic pizza making machine that oversees the complete pizza production process. The system should initiate the pizza-making process when the start button is pressed, provided the stop button is not engaged. It must activate the dough roller motor when the dough is not yet ready. When the dough is ready but the toppings are not, the topping dispenser should be activated. Once both the dough and toppings are ready, the system should move the pizza to the oven using a conveyor motor. Additionally, the oven temperature must be controlled; it should be set to 220°C during the baking process and return to 0°C once baking is completed. The machine needs to stop all operations immediately when the stop button is pressed. Utilizing sensors, the system should accurately detect the readiness status of the dough and toppings, along with the completion of baking. Ensure safe operation by preventing conflicting actions and maintaining a proper sequence of operations throughout the entire process. Please ensure that the output ST code complies with the syntax rules. The function block should use the following structure:\n\nFUNCTION_BLOCK PizzaMakingMachine\nVAR_INPUT\n    StartButton : BOOL;\n    StopButton : BOOL;\n    DoughReadySensor : BOOL;\n    ToppingsReadySensor : BOOL;\n    BakingDoneSensor : BOOL;\nEND_VAR\n\nVAR_OUTPUT\n    DoughRollerMotor : BOOL;\n    ToppingDispenser : BOOL;\n    ConveyorMotor : BOOL;\n    OvenHeater : BOOL;\n    OvenTemperature : INT;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the dough roller motor is activated when the start button is pressed and dough is not ready.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.StopButton AND NOT instance.DoughReadySensor",
          "1": "instance.DoughRollerMotor"
        },
        "pattern_description": "If {instance.StartButton AND NOT instance.StopButton AND NOT instance.DoughReadySensor} is true at the end of the PLC cycle, then {instance.DoughRollerMotor} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the topping dispenser is activated when dough is ready but toppings are not.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.StopButton AND instance.DoughReadySensor AND NOT instance.ToppingsReadySensor",
          "1": "instance.ToppingDispenser"
        },
        "pattern_description": "If {instance.StartButton AND NOT instance.StopButton AND instance.DoughReadySensor AND NOT instance.ToppingsReadySensor} is true at the end of the PLC cycle, then {instance.ToppingDispenser} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the conveyor motor is activated when both dough and toppings are ready and baking is not done.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.StopButton AND instance.DoughReadySensor AND instance.ToppingsReadySensor AND NOT instance.BakingDoneSensor",
          "1": "instance.ConveyorMotor"
        },
        "pattern_description": "If {instance.StartButton AND NOT instance.StopButton AND instance.DoughReadySensor AND instance.ToppingsReadySensor AND NOT instance.BakingDoneSensor} is true at the end of the PLC cycle, then {instance.ConveyorMotor} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the oven heater is on and temperature is set to 220°C when baking is in progress.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.StopButton AND instance.DoughReadySensor AND instance.ToppingsReadySensor AND NOT instance.BakingDoneSensor",
          "1": "instance.OvenHeater AND instance.OvenTemperature = 220"
        },
        "pattern_description": "If {instance.StartButton AND NOT instance.StopButton AND instance.DoughReadySensor AND instance.ToppingsReadySensor AND NOT instance.BakingDoneSensor} is true at the end of the PLC cycle, then {instance.OvenHeater AND instance.OvenTemperature = 220} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that all operations stop when the stop button is pressed.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton",
          "1": "NOT instance.DoughRollerMotor AND NOT instance.ToppingDispenser AND NOT instance.ConveyorMotor AND NOT instance.OvenHeater AND instance.OvenTemperature = 0"
        },
        "pattern_description": "If {instance.StopButton} is true at the end of the PLC cycle, then {NOT instance.DoughRollerMotor AND NOT instance.ToppingDispenser AND NOT instance.ConveyorMotor AND NOT instance.OvenHeater AND instance.OvenTemperature = 0} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-30"
}
{
  "instruction": "Develop a FUNCTION_BLOCK in Structured Text (ST) for a smart road traffic management system aimed at optimizing traffic flow through effective signal timings. The system should monitor vehicle counts at four distinct intersections and compare vehicle counts between two pairs of intersections (1 vs 2 and 3 vs 4). It must set the traffic light for the intersection with the higher vehicle count to green, ensuring that opposing intersections always have complementary light states (i.e., when one is green, the other is red). The system should continuously update the states of the traffic lights based on real-time vehicle count data while implementing efficient logic to manage the two pairs of intersections independently. Please ensure that the output ST code complies with the applicable syntax rules. The function block should be structured as follows: \n\nFUNCTION_BLOCK TrafficManagementSystem\nVAR_INPUT\n    VehicleCount1 : INT;\n    VehicleCount2 : INT;\n    VehicleCount3 : INT;\n    VehicleCount4 : INT;\nEND_VAR\n\nVAR_OUTPUT\n    TrafficLight1 : BOOL;\n    TrafficLight2 : BOOL;\n    TrafficLight3 : BOOL;\n    TrafficLight4 : BOOL;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that when VehicleCount1 is greater than VehicleCount2, TrafficLight1 is green and TrafficLight2 is red.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.VehicleCount1 > instance.VehicleCount2",
          "1": "instance.TrafficLight1 AND NOT instance.TrafficLight2"
        },
        "pattern_description": "If {instance.VehicleCount1 > instance.VehicleCount2} is true at the end of the PLC cycle, then {instance.TrafficLight1 AND NOT instance.TrafficLight2} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that when VehicleCount2 is greater than or equal to VehicleCount1, TrafficLight2 is green and TrafficLight1 is red.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.VehicleCount2 >= instance.VehicleCount1",
          "1": "instance.TrafficLight2 AND NOT instance.TrafficLight1"
        },
        "pattern_description": "If {instance.VehicleCount2 >= instance.VehicleCount1} is true at the end of the PLC cycle, then {instance.TrafficLight2 AND NOT instance.TrafficLight1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that when VehicleCount3 is greater than VehicleCount4, TrafficLight3 is green and TrafficLight4 is red.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.VehicleCount3 > instance.VehicleCount4",
          "1": "instance.TrafficLight3 AND NOT instance.TrafficLight4"
        },
        "pattern_description": "If {instance.VehicleCount3 > instance.VehicleCount4} is true at the end of the PLC cycle, then {instance.TrafficLight3 AND NOT instance.TrafficLight4} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that when VehicleCount4 is greater than or equal to VehicleCount3, TrafficLight4 is green and TrafficLight3 is red.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.VehicleCount4 >= instance.VehicleCount3",
          "1": "instance.TrafficLight4 AND NOT instance.TrafficLight3"
        },
        "pattern_description": "If {instance.VehicleCount4 >= instance.VehicleCount3} is true at the end of the PLC cycle, then {instance.TrafficLight4 AND NOT instance.TrafficLight3} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that TrafficLight1 and TrafficLight2 are always in opposite states.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "0": "instance.TrafficLight1 <> instance.TrafficLight2"
        },
        "pattern_description": "{instance.TrafficLight1 <> instance.TrafficLight2} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that TrafficLight3 and TrafficLight4 are always in opposite states.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "0": "instance.TrafficLight3 <> instance.TrafficLight4"
        },
        "pattern_description": "{instance.TrafficLight3 <> instance.TrafficLight4} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-31"
}
{
  "instruction": "Develop a FUNCTION_BLOCK in Structured Text (ST) for a 3D pouch making machine with the following specifications and requirements: The machine includes 8 heating stations and 8 cooling stations, with one horizontal and one vertical cutter at the end of the machine. It features two feeder units supplying raw material, and maintaining winding tension is crucial throughout the machine. Implement a detailed start-up sequence that activates the heating and cooling stations, starts the feeders while establishing proper winding tension, activates the horizontal and vertical cutters, and sets the machine to a ready state. Additionally, implement a detailed shutdown sequence that stops the cutters, stops the feeders, deactivates the heating and cooling stations, and sets the machine to a not-ready state. Include input variables for starting and stopping the machine and output variables to indicate the status of various components (feeders, cutters, heating/cooling stations) and overall machine readiness. Ensure that the start-up and shutdown sequences are executed in the correct order while addressing all safety considerations. Please ensure that the output ST code complies with the syntax rules. The function block should use the following structure: \n\nFUNCTION_BLOCK PouchMachine\nVAR_INPUT\n    start_machine: BOOL;\n    stop_machine: BOOL;\nEND_VAR\n\nVAR_OUTPUT\n    machine_ready: BOOL;\n    feeder_running: BOOL;\n    cutter_running: BOOL;\n    heating_running: BOOL;\n    cooling_running: BOOL;\nEND_VAR\n\nVAR\n    startup_complete: BOOL := FALSE;\n    shutdown_complete: BOOL := FALSE;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that when the start_machine signal is received, stop_machine is false, and the machine is not ready, all components are activated and the machine becomes ready.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.start_machine AND NOT instance.stop_machine AND NOT instance.machine_ready",
          "1": "instance.machine_ready AND instance.feeder_running AND instance.cutter_running AND instance.heating_running AND instance.cooling_running"
        },
        "pattern_description": "If {instance.start_machine AND NOT instance.stop_machine AND NOT instance.machine_ready} is true at the end of the PLC cycle, then {instance.machine_ready AND instance.feeder_running AND instance.cutter_running AND instance.heating_running AND instance.cooling_running} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that when the stop_machine signal is received and the machine is ready, all components are deactivated and the machine becomes not ready.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.stop_machine AND instance.machine_ready",
          "1": "NOT instance.machine_ready AND NOT instance.feeder_running AND NOT instance.cutter_running AND NOT instance.heating_running AND NOT instance.cooling_running"
        },
        "pattern_description": "If {instance.stop_machine AND instance.machine_ready} is true at the end of the PLC cycle, then {NOT instance.machine_ready AND NOT instance.feeder_running AND NOT instance.cutter_running AND NOT instance.heating_running AND NOT instance.cooling_running} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the machine cannot be simultaneously in a ready state and receiving a stop signal.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "0": "instance.machine_ready AND instance.stop_machine AND instance.start_machine"
        },
        "pattern_description": "{instance.machine_ready AND instance.stop_machine AND instance.start_machine} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that when the machine is ready, all components are running.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.machine_ready",
          "1": "instance.feeder_running AND instance.cutter_running AND instance.heating_running AND instance.cooling_running"
        },
        "pattern_description": "If {instance.machine_ready} is true at the end of the PLC cycle, then {instance.feeder_running AND instance.cutter_running AND instance.heating_running AND instance.cooling_running} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that when any component is not running, the machine is not in a ready state.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT instance.feeder_running OR NOT instance.cutter_running OR NOT instance.heating_running OR NOT instance.cooling_running",
          "1": "NOT instance.machine_ready"
        },
        "pattern_description": "If {NOT instance.feeder_running OR NOT instance.cutter_running OR NOT instance.heating_running OR NOT instance.cooling_running} is true at the end of the PLC cycle, then {NOT instance.machine_ready} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-32"
}
{
  "instruction": "Develop a FUNCTION_BLOCK in Structured Text (ST) according to IEC 61131-3 for implementing feedforward control for mixing two reactants. The function block should accept input flow rates for two reactants and a desired mixing ratio, and calculate the output flow rates to maintain the desired mixing ratio. It must ensure that all flow rates (input and output) are within a specified range of 0 to 100. Implement the following logic: limit input flow rates to the allowed range (0 to 100), calculate the total mixed flow rate, calculate output flow rates based on the mixing ratio and total flow rate, and limit output flow rates to the allowed range (0 to 100). Use the REAL data type for all flow rates and the mixing ratio. Additionally, implement error handling to prevent division by zero when calculating output flow rates. Please ensure that the output ST code complies with the syntax rules. The function block should use the following structure:\n\nFUNCTION_BLOCK FeedForwardControl\nVAR_INPUT\n    FlowRate1, FlowRate2: REAL; // Input flow rates of reactants\n    MixRatio: REAL; // Desired mixing ratio (Reactant1:Reactant2)\nEND_VAR\n\nVAR_OUTPUT\n    OutFlowRate1, OutFlowRate2: REAL; // Output flow rates for reactants to maintain the mixing ratio\nEND_VAR\n\nVAR\n    MixedFlowRate: REAL; // Total mixed flow rate\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that input flow rates are always within the allowed range.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "0": "(instance.FlowRate1 >= 0.0 AND instance.FlowRate1 <= 100.0) AND (instance.FlowRate2 >= 0.0 AND instance.FlowRate2 <= 100.0)"
        },
        "pattern_description": "{(instance.FlowRate1 >= 0.0 AND instance.FlowRate1 <= 100.0) AND (instance.FlowRate2 >= 0.0 AND instance.FlowRate2 <= 100.0)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that output flow rates are always within the allowed range.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "0": "(instance.OutFlowRate1 >= 0.0 AND instance.OutFlowRate1 <= 100.0) AND (instance.OutFlowRate2 >= 0.0 AND instance.OutFlowRate2 <= 100.0)"
        },
        "pattern_description": "{(instance.OutFlowRate1 >= 0.0 AND instance.OutFlowRate1 <= 100.0) AND (instance.OutFlowRate2 >= 0.0 AND instance.OutFlowRate2 <= 100.0)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that division by zero is avoided when calculating output flow rates.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "0": "instance.MixRatio = 0.0"
        },
        "pattern_description": "{instance.MixRatio = 0.0} is impossible at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-33"
}
{
  "instruction": "Implement a function block in structured text (ST) to control a simple state machine with request and completion signals. The function block should have the following features and behavior: 1. Two states: Idle (0) and Processing (1). 2. Input signals: request (BOOL) and done (BOOL). 3. Output signal: listen (BOOL). 4. State transitions: ○ From Idle to Processing: When request is TRUE. ○ From Processing to Idle: When done is TRUE. 5. Behavior: ○ In Idle state: Set listen to TRUE when no request is present. ○ In Processing state: Keep the state until done signal is received. 6. Ensure that listen is only TRUE in the Idle state. 7. Implement safe state transitions and signal processing based on the current state and input signals.Please ensure that the output ST code complies with the syntax rules.The function block should use the following structure:\n\nFUNCTION_BLOCK StateMachineControl\nVAR_INPUT\n    request : BOOL;\n    done : BOOL;\nEND_VAR\n\nVAR_OUTPUT\n    listen : BOOL;\nEND_VAR\n\nVAR\n    state : INT := 0;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that listen is TRUE only in the Idle state (state 0).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.listen",
          "1": "instance.state = 0"
        },
        "pattern_description": "If {instance.listen} is true at the end of the PLC cycle, then {instance.state = 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the state transitions to Processing (state 1) when a request is received in the Idle state.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "0": "instance.state = 0 AND instance.request",
          "1": "instance.state = 1"
        },
        "pattern_description": "If {instance.state = 0 AND instance.request} is true at the beginning of the PLC cycle, then {instance.state = 1} is always true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the state transitions back to Idle (state 0) when the done signal is received in the Processing state.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "0": "instance.state = 1 AND instance.done",
          "1": "instance.state = 0"
        },
        "pattern_description": "If {instance.state = 1 AND instance.done} is true at the beginning of the PLC cycle, then {instance.state = 0} is always true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the state remains in Processing (state 1) when the done signal is not received.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.state = 1 AND NOT instance.done",
          "1": "instance.state = 1"
        },
        "pattern_description": "If {instance.state = 1 AND NOT instance.done} is true at the end of the PLC cycle, then {instance.state = 1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the state is always either 0 or 1.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.state = 0 OR instance.state = 1"
        },
        "pattern_description": "{instance.state = 0 OR instance.state = 1} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-34"
}
{
  "instruction": "Create a function block that implements the following logic based on the provided program:\n\nInput Variables:\n\nDefine an input variable named INPUT_VAR1 of type INT to represent the initial value (starting with 2).\nDefine an input variable named INPUT_COUNTER of type INT to control the number of iterations (starting with 4).\nOutput Variables:\n\nDefine an output variable named OUTPUT_VAR1 of type INT to store the final computed value after the repetitions.\nLogic Implementation:\n\nImplement a REPEAT loop that multiplies OUTPUT_VAR1 by 2 for INPUT_COUNTER iterations, decrementing INPUT_COUNTER each time until it reaches zero. Ensure that the multiplication starts with OUTPUT_VAR1 initialized to INPUT_VAR1.\nControl Flow:\n\nThe loop should terminate once INPUT_COUNTER equals 0.\nEnsure that the generated function block maintains the original program's functionality while adhering to structured text programming standards.\n\nFUNCTION_BLOCK FB_SimpleRepeat\nVAR_INPUT\nINPUT_VAR1 : INT := 2;\nINPUT_COUNTER : INT := 4;\nEND_VAR\n\nVAR_OUTPUT\nOUTPUT_VAR1 : INT;\nEND_VAR\n\nVAR\nCOUNTER : INT;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that OUTPUT_VAR1 is equal to INPUT_VAR1 multiplied by 16 at the end of the PLC cycle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.INPUT_VAR1 = 2 AND instance.INPUT_COUNTER = 4",
          "2": "instance.OUTPUT_VAR1 = 32"
        },
        "pattern_description": "If {instance.INPUT_VAR1 = 2 AND instance.INPUT_COUNTER = 4} is true at the end of the PLC cycle, then {instance.OUTPUT_VAR1 = 32} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that COUNTER reaches 0 after completing the loop.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.tmp_COUNTER = 0"
        },
        "pattern_description": "At the end of the PLC cycle, {instance.INPUT_tmp_COUNTER} should always equal 0 after the loop is completed."
      }
    }
  ],
  "id": "v2-M-35"
}
{
  "instruction": "Design a function block named CourseDifferenceControl that computes the difference between two integer inputs KOMPASS_GRAD and KURS.\n\nThe function block should ensure that if KOMPASS_GRAD is less than 0,\nthe output should be 0.\n\nOtherwise, calculate the difference between KURS and KOMPASS_GRAD.\n\nIf the difference is greater than 1800, subtract 3600 from it;\nif it is less than -1800, add 3600. Finally, call this function block in the MAIN program and ensure that\nall logic for course correction is accurately represented.\n\nValidate properties that ensure the correct handling of angle differences,\nincluding range corrections and boundary conditions.\n\nFUNCTION_BLOCK FB_CourseDifferenceControl\nVAR_INPUT\nKOMPASS_GRAD  : INT;\nKURS  : INT;\nEND_VAR\nVAR_OUTPUT\nKURS_DIFF  : INT;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that if KOMPASS_GRAD is less than 0, the output KURS_DIFF is always 0.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.KOMPASS_GRAD < 0",
          "1": "instance.KURS_DIFF = 0"
        },
        "pattern_description": "If {instance.KOMPASS_GRAD < 0}, then {instance.KURS_DIFF = 0} should always be true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that if KOMPASS_GRAD is greater than or equal to 0, the course difference is correctly calculated as KURS - KOMPASS_GRAD.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.KOMPASS_GRAD >= 0 AND (instance.KURS - instance.KOMPASS_GRAD) <= 1800 AND (instance.KURS - instance.KOMPASS_GRAD) >= -1800",
          "1": "instance.KURS_DIFF = instance.KURS - instance.KOMPASS_GRAD"
        },
        "pattern_description": "If {instance.KOMPASS_GRAD >= 0 AND (instance.KURS - instance.KOMPASS_GRAD) <= 1800 AND (instance.KURS - instance.KOMPASS_GRAD) >= -1800}, then {instance.KURS_DIFF = instance.KURS - instance.KOMPASS_GRAD} should always be true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that if the difference (KURS_DIFF) exceeds 1800, 3600 is subtracted from the result.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.KOMPASS_GRAD >= 0 AND (instance.KURS - instance.KOMPASS_GRAD) > 1800",
          "1": "instance.KURS_DIFF = (instance.KURS - instance.KOMPASS_GRAD) - 3600"
        },
        "pattern_description": "If {(instance.KURS - instance.KOMPASS_GRAD) > 1800}, then {instance.KURS_DIFF = (instance.KURS - instance.KOMPASS_GRAD) - 3600} should always be true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that if the difference (KURS_DIFF) is less than -1800, 3600 is added to the result.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.KOMPASS_GRAD >= 0 AND (instance.KURS - instance.KOMPASS_GRAD) < -1800",
          "1": "instance.KURS_DIFF = (instance.KURS - instance.KOMPASS_GRAD) + 3600"
        },
        "pattern_description": "If {(instance.KURS - instance.KOMPASS_GRAD) < -1800}, then {instance.KURS_DIFF = (instance.KURS - instance.KOMPASS_GRAD) + 3600} should always be true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-36"
}
{
  "instruction": "Create a function block named 'FB_ThresholdAccumulator' that processes an input value and produces an output based on specific conditions. The function block should have the following characteristics:\nInput and Output\n\nInput: An integer value i\nOutput: An integer value o\n\nInternal Variables\n\nAn integer s1 for intermediate calculations\n\nLogic\n\nInitialize s1 to 0 at the start of each function block call.\nIf the input i is greater than 0, add its value to s1.\nAfter the first condition, if s1 equals 42, add 8000 to s1.\nFor the final output:\n\nIf s1 is less than 0, set the output o to 0.\nOtherwise, set the output o to the current value of s1.\n\n\n\nImplement this logic using Structured Text (ST) in a function block format, ensuring that the input and output variables are clearly defined and the internal logic matches the described steps.\n\n\nFUNCTION_BLOCK FB_ThresholdAccumulator\nVAR_INPUT\ni : INT;\nEND_VAR\n\nVAR_OUTPUT\no : INT;\nEND_VAR\n\nVAR\ns1 : INT;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the output is always non-negative.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.o >= 0"
        },
        "pattern_description": "{instance.o >= 0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "If the input is non-positive, the output should be zero or remain unchanged.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.i <= 0",
          "2": "instance.o = 0 OR instance.o = instance.s1"
        },
        "pattern_description": "If {instance.i <= 0} is true at the end of the PLC cycle, then {instance.o = 0 OR instance.o = instance.s1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "The output should never exceed the maximum value for a DINT (2147483647).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.o <= 2147483647"
        },
        "pattern_description": "{instance.o <= 2147483647} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-37"
}
{
  "instruction": "Create a function block in Structured Text (ST) that selects a value based on a condition and then performs an aggregation. The function block should have the following characteristics:\n\nName: FB_ConditionalSelectAndAggregate\nInput/Output variables:\n\nVAR_INPUT\nZ : INT;  // External input value for comparison and potential selection\nVAR_OUTPUT\nNEW_Z : INT;  // Result of the selection and aggregation\n\n\nInternal constants:\n\nA_X : INT := 42;  // Threshold for comparison\nA_Y : INT := 333; // Alternative value for selection\n\n\nLogic:\na. Conditional Selection:\n\nIf A_X > Z, select A_Y\nOtherwise, select Z\nStore the selected value in NEW_Z\nb. Aggregation:\nAdd A_X and A_Y to the selected value in NEW_Z\n\n\nImplementation notes:\n\nDo not include comments in the function block\nEnsure the selection occurs before the aggregation\nUse a single assignment for NEW_Z in each branch of the condition\nPerform the final aggregation in a separate statement\n\nFUNCTION_BLOCK FB_ConditionalSelectAndAggregate\nVAR_INPUT\nZ : INT;\nEND_VAR\nVAR\nA_X : INT := 42;\nA_Y : INT := 333;\nEND_VAR\nVAR_OUTPUT\nNEW_Z : INT;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that when A_X (42) is greater than OLD_Z, NEW_Z is equal to A_X plus twice A_Y.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ax > instance.old_z",
          "1": "instance.newz = instance.ax + instance.ay * 2"
        },
        "pattern_description": "If {instance.ax > instance.old_z} is true at the end of the PLC cycle, then {instance.newz = instance.ax + instance.ay * 2} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that when A_X (42) is not greater than OLD_Z, NEW_Z is equal to A_X plus A_Y plus OLD_Z.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT (instance.ax > instance.old_z)",
          "1": "instance.newz = instance.ax + instance.ay + instance.old_z"
        },
        "pattern_description": "If {NOT (instance.ax > instance.old_z)} is true at the end of the PLC cycle, then {instance.newz = instance.ax + instance.ay + instance.old_z} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-38"
}
{
  "instruction": "Create a function block that implements a control logic system with the following behavior:\nInputs:request (BOOL): Indicates if a request has been made.done (BOOL): Indicates if the processing is completed.\nOutput:listen (BOOL): Indicates whether the system is in listening mode.\n State Management: The system starts in state 0. In state 0, if request is FALSE, set listen to TRUE and remain in state 0.If request is TRUE, set listen to FALSE, transition to state 1, and set done to FALSE. In state 1, if done is FALSE, remain in state 1. If done becomes TRUE, transition back to state 0 and set listen to TRUE.FUNCTION_BLOCK FB_RequestHandler\nVAR_IN\nrequest : BOOL;\ndone : BOOL;\nEND_VAR_IN\nVAR_OUT\nlisten : BOOL;\nEND_VAR_OUT\nVAR\nstate : INT := 0;\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that 'listen' is TRUE when the system is in state 0 and 'request' is FALSE.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "1": "(instance.state = 0) AND (instance.request = FALSE)",
          "2": "(instance.listen = TRUE) AND (instance.state = 0)"
        },
        "pattern_description": "{instance.listen = TRUE} is always true at the end of the PLC cycle when the system is in state 0 and 'request' is FALSE."
      }
    },
    {
      "property_description": "Ensure that 'listen' is TRUE when the system is in state 0 and 'request' is FALSE.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "1": "(instance.state = 0) AND (instance.request = TRUE) AND (NOT instance.done)",
          "2": "(instance.listen = FALSE) AND (instance.state = 1)"
        },
        "pattern_description": "{instance.listen = TRUE} is always true at the end of the PLC cycle when the system is in state 0 and 'request' is FALSE."
      }
    },
    {
      "property_description": "Ensure that 'listen' is TRUE when the system is in state 0 and 'request' is FALSE.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "1": "(instance.state = 1) AND (instance.done = FALSE)",
          "2": "(instance.state = 1)"
        },
        "pattern_description": "{instance.listen = TRUE} is always true at the end of the PLC cycle when the system is in state 0 and 'request' is FALSE."
      }
    },
    {
      "property_description": "Ensure that 'listen' is TRUE when the system is in state 0 and 'request' is FALSE.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "1": "(instance.state = 1) AND (instance.done)",
          "2": "(instance.listen = TRUE) AND (instance.state = 0)"
        },
        "pattern_description": "{instance.listen = TRUE} is always true at the end of the PLC cycle when the system is in state 0 and 'request' is FALSE."
      }
    }
  ],
  "id": "v2-M-39"
}
{
  "instruction": "Create a Structured Text (ST) function block named FB_Sum that replicates the functionality of the provided ST program. The function block should include the following characteristics:\n\nInput Variables:\nmaxValue (INT): This variable specifies the maximum value for a summation loop.\n\nOutput Variables:\nwData (WORD): This variable should store the sum of integers from 0 to maxValue.\n\nFunctionality:\nThe function block should perform the following operations:\nInitialize wData to 0.\nUse a FOR loop to iterate from 0 to maxValue, incrementing wData by the loop index (II) in each iteration.\n\nFUNCTION_BLOCK FB_Sum\nVAR_INPUT\nmaxValue : INT;\nEND_VAR\nVAR_OUTPUT\nwData : WORD;\nEND_VAR\n\nVAR\nII : INT;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that the output wData holds the correct sum of integers from 0 to maxValue.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.maxValue >= 0",
          "1": "instance.wData = (instance.maxValue * (instance.maxValue + 1)) / 2"
        },
        "pattern_description": "{instance.wData = (instance.maxValue * (instance.maxValue + 1)) / 2} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the output wData is 0 when maxValue is less than 0.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.maxValue < 0",
          "1": "instance.wData = 0"
        },
        "pattern_description": "{instance.maxValue < 0 => instance.wData = 0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the output wData does not exceed the maximum value for a WORD.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.wData <= 65535"
        },
        "pattern_description": "{instance.wData <= 65535} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-40"
}
{
  "instruction": "Create a structured text (ST) code that simulates a pedestrian traffic light control system. The system should handle the logic for controlling both car and pedestrian lights based on a button press and a counter.\n\nThe input variable pedBtnPress should represent whether the pedestrian button has been pressed.\nThe output variables should include:\ncarLightIsGreen: a boolean indicating if the car light is green.\npedLightIsGreen: a boolean indicating if the pedestrian light is green.\ncounter: an integer to track the timer for light changes.\nImplement the following logic:\nWhen the pedestrian button is pressed and it was not pressed before, the car light should turn red.\nAt a counter value of 10, the pedestrian light should turn green.\nAt a counter value of 40, the pedestrian light should turn red.\nAt a counter value of 50, the car light should turn green.\nIf the car light is red, increment the counter; if the car light is green, reset the counter to 0.\nEnsure the control logic reflects a proper state machine where the status of the lights changes appropriately based on the button press and counter values.\n\nFUNCTION_BLOCK FB_PedestrianTrafficLight\nVAR_INPUT\npedBtnPress : BOOL;\nEND_VAR\nVAR_OUTPUT\ncarLightIsGreen : BOOL;\npedLightIsGreen : BOOL;\nTimeCounter : INT;\nEND_VAR\nVAR\nbuttonPressedBefore : BOOL := FALSE;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that when the button is pressed and it was not pressed before, the car light turns red during the cycle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "0": "NOT instance.buttonPressedBefore AND instance.pedBtnPress AND (instance.TimeCounter <> 50)",
          "1": "instance.carLightIsGreen = FALSE"
        },
        "entry_point": "FB_PedestrianTrafficLight",
        "pattern_description": "If {NOT instance.buttonPressedBefore AND instance.pedBtnPress AND (instance.TimeCounter <> 50)} is true at the beginning of the PLC cycle, then {instance.carLightIsGreen = FALSE} is always true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the TimeCounter increments when it equals 10 in the current cycle.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "0": "instance.TimeCounter = 10",
          "1": "instance.TimeCounter = 11"
        },
        "entry_point": "FB_PedestrianTrafficLight",
        "pattern_description": "If {instance.TimeCounter = 10} is true at the beginning of the PLC cycle, then {instance.TimeCounter = 11} should be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the pedestrian light turns green when the counter reaches 11.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TimeCounter = 11",
          "1": "instance.pedLightIsGreen"
        },
        "entry_point": "FB_PedestrianTrafficLight",
        "pattern_description": "If {instance.TimeCounter = 11} is true at the end of the PLC cycle, then {instance.pedLightIsGreen = TRUE} should be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the pedestrian light turns off when the counter reaches 41.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TimeCounter = 41",
          "1": "instance.pedLightIsGreen = FALSE"
        },
        "entry_point": "FB_PedestrianTrafficLight",
        "pattern_description": "If {instance.TimeCounter = 41} is true at the end of the PLC cycle, then {instance.pedLightIsGreen = FALSE} should be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the car light is green when the TimeCounter reaches 50.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "0": "instance.TimeCounter = 50",
          "1": "instance.carLightIsGreen"
        },
        "entry_point": "FB_PedestrianTrafficLight",
        "pattern_description": "If {instance.TimeCounter = 50} is true at the beginning of the PLC cycle, then {instance.carLightIsGreen = TRUE} is always true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that when the car light is green, the TimeCounter resets to 0.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.carLightIsGreen",
          "1": "instance.TimeCounter = 0"
        },
        "entry_point": "FB_PedestrianTrafficLight",
        "pattern_description": "If {instance.carLightIsGreen = TRUE} is true at the end of the PLC cycle, then {instance.TimeCounter = 0} should also be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-41"
}

{
  "instruction": "Develop a PLC program in Structured Text (ST) to automate the operation of a multi-level car parking system. The program should manage the allocation and retrieval of cars in up to 100 parking spaces, while handling the logic for entry and exit gates and ensuring smooth car movements. The following functionalities are required:\n1.Entry Gate Management:\noDetect when a car arrives at the entry gate using the EntryGateSensor.\noAllocate the first available parking space to the arriving car by scanning an array of 100 parking spaces (ParkingSpaces).\noMark the assigned parking space as occupied (TRUE) and output the assigned parking space number through ParkingSpaceNumber.\noEnsure no parking space is allocated if car retrieval is currently in progress (RetrievalInProgress is TRUE).\n2.Exit Gate Management:\noDetect when a car leaves through the exit gate using the ExitGateSensor.\noMark the corresponding parking space as available (FALSE) once the car has exited.\noReset the ParkingSpaceNumber output to 0 after the car has exited.\n3.Car Retrieval Management:\noWhen a car retrieval request is detected via CarDetected, set the RetrievalInProgress flag to TRUE.\noExecute the retrieval logic by moving the car from its allocated parking space to the exit gate using a helper function, MoveCarToExitGate.\noOnce retrieval is complete, mark the corresponding parking space as available (FALSE) and reset ParkingSpaceNumber to 0.\noEnsure the system is ready for new parking allocations once the retrieval is complete by resetting RetrievalInProgress to FALSE.\n4.Parking Space Tracking:\noMaintain an array of 100 parking spaces (ParkingSpaces), where each space is represented as a boolean (TRUE for occupied, FALSE for available).\noUse a loop to scan the array for the first available parking space during car arrival.\n5.Car Movement Handling:\noImplement car movement logic in the helper function MoveCarToExitGate, which facilitates transferring cars from their allocated spaces to the exit gate. The function should return TRUE when the movement is successfully completed.\nThe program should ensure efficient utilization of parking spaces, proper synchronization between parking allocation and car retrieval, and seamless operation of entry and exit gates. All outputs and status indicators should update in real time to reflect the current state of the parking system.\nFUNCTION_BLOCK Automated_Parking_Controller\nVAR_INPUT\n EntryGateSensor : BOOL; (* Sensor input for entry gate *)\n ExitGateSensor : BOOL; (* Sensor input for exit gate *)\n CarDetected : BOOL; (* Sensor input for car detection *)\nEND_VAR\nVAR_OUTPUT\n ParkingSpaceNumber : INT := 0; (* Allocated parking space number *)\n RetrievalInProgress : BOOL := FALSE; (* Flag for car retrieval in progress *)\nEND_VAR\nVAR\n ParkingSpaces : ARRAY[1..100] OF BOOL; (* Parking space status: TRUE=Occupied, FALSE=Available *)\n i : INT; (* Loop counter *)\nEND_VAR\nEND_FUNCTION\nFUNCTION MoveCarToExitGate : BOOL\nVAR_INPUT\n SpaceNumber : INT;\nEND_VAR\nEND_FUNCTION",
  "properties_to_be_validated": [
    {
      "property_description": "Parking space number must be within valid range",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.ParkingSpaceNumber >= 0 AND instance.ParkingSpaceNumber <= 100"
        },
        "entry_point": "Automated_Parking_Controller",
        "pattern_description": "{instance.ParkingSpaceNumber >= 0 AND instance.ParkingSpaceNumber <= 100} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Cannot process new car entry during retrieval",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.RetrievalInProgress = TRUE AND instance.EntryGateSensor = TRUE"
        },
        "entry_point": "Automated_Parking_Controller",
        "pattern_description": "{instance.RetrievalInProgress = TRUE AND instance.EntryGateSensor = TRUE} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Space must be freed after car exits",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ExitGateSensor = TRUE AND instance.ParkingSpaceNumber = 1",
          "1": "instance.ParkingSpaces[1] = FALSE"
        },
        "entry_point": "Automated_Parking_Controller",
        "pattern_description": "If {instance.ExitGateSensor = TRUE AND instance.ParkingSpaceNumber = 1} is true at the end of the PLC cycle, then {instance.ParkingSpaces[1] = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Space must be freed after car exits (Space 2)",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ExitGateSensor = TRUE AND instance.ParkingSpaceNumber = 2",
          "1": "instance.ParkingSpaces[2] = FALSE"
        },
        "entry_point": "Automated_Parking_Controller",
        "pattern_description": "If {instance.ExitGateSensor = TRUE AND instance.ParkingSpaceNumber = 2} is true at the end of the PLC cycle, then {instance.ParkingSpaces[2] = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Cannot start new retrieval while another is in progress",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.RetrievalInProgress = TRUE AND instance.CarDetected = TRUE"
        },
        "entry_point": "Automated_Parking_Controller",
        "pattern_description": "{instance.RetrievalInProgress = TRUE AND instance.CarDetected = TRUE} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Parking space must be valid during retrieval",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT instance.RetrievalInProgress OR instance.ParkingSpaceNumber > 0"
        },
        "entry_point": "Automated_Parking_Controller",
        "pattern_description": "{NOT instance.RetrievalInProgress OR instance.ParkingSpaceNumber > 0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Retrieval state must be consistent",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.RetrievalInProgress = TRUE AND instance.ParkingSpaceNumber = 0"
        },
        "entry_point": "Automated_Parking_Controller",
        "pattern_description": "{instance.RetrievalInProgress = TRUE AND instance.ParkingSpaceNumber = 0} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Retrieval flag must be properly reset",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT instance.RetrievalInProgress OR instance.ParkingSpaceNumber > 0"
        },
        "entry_point": "Automated_Parking_Controller",
        "pattern_description": "{NOT instance.RetrievalInProgress OR instance.ParkingSpaceNumber > 0} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-42"
}

{
  "instruction": "Develop a PLC program in Structured Text (ST) to implement a bakery oven control system that regulates temperature, humidity, and baking time to ensure optimal baking conditions. The program should take sensor inputs for the current oven temperature and humidity and use these inputs to control a heating element, a cooling element, a humidity control system, and a dehumidification system. The logic should ensure that the heating element is activated when the temperature falls below the desired setpoint minus a configurable threshold, and the cooling element is activated when the temperature exceeds the desired setpoint plus the threshold, with both systems turned off when the temperature is within the acceptable range. Similarly, the humidity control system should activate when the measured humidity is below the setpoint minus a configurable threshold, and the dehumidification system should activate when the humidity is above the setpoint plus the threshold, with both systems turned off when the humidity is within the acceptable range. The program should also include functionality to decrement a baking timer at one-second intervals, and when the timer reaches zero, all systems should be turned off to indicate that baking is complete. The oven's setpoints for temperature, humidity, and baking time should be initialized when the oven is off, and the program should ensure that all control outputs are deactivated in this state. The implementation should use clear and descriptive variable names, include appropriate comments for readability and maintenance, and allow for easy calibration and adjustment of thresholds and setpoints to accommodate different baking requirements.\nFUNCTION_BLOCK BakeryOvenControl\nVAR_INPUT\n TemperatureSensor : REAL; (* Sensor input for oven temperature *)\n HumiditySensor : REAL; (* Sensor input for oven humidity *)\nEND_VAR\nVAR_OUTPUT\n HeatingElement : BOOL; (* Control signal for heating element *)\n CoolingElement : BOOL; (* Control signal for cooling element *)\n HumidityControl : BOOL; (* Control signal for humidity system *)\n DehumidityControl : BOOL; (* Control signal for dehumidification *)\nEND_VAR\nVAR\n OvenTemperature : REAL := 0.0; (* Current oven temperature setpoint *)\n OvenHumidity : REAL := 0.0; (* Current oven humidity setpoint *)\n BakingTime : TIME := T#0s; (* Baking time setpoint *)\n OvenStatus : BOOL := FALSE; (* Oven status: TRUE=On, FALSE=Off *)\n HeatingThreshold : REAL := 2.0; (* Temperature control threshold *)\n HumidityThreshold : REAL := 5.0; (* Humidity control threshold *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Heating and cooling elements cannot be active simultaneously",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.HeatingElement = TRUE AND instance.CoolingElement = TRUE"
        },
        "entry_point": "BakeryOvenControl",
        "pattern_description": "{instance.HeatingElement = TRUE AND instance.CoolingElement = TRUE} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Humidity and dehumidity controls cannot be active simultaneously",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.HumidityControl = TRUE AND instance.DehumidityControl = TRUE"
        },
        "entry_point": "BakeryOvenControl",
        "pattern_description": "{instance.HumidityControl = TRUE AND instance.DehumidityControl = TRUE} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Heating must be active when temperature is too low",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor < (instance.OvenTemperature - instance.HeatingThreshold) AND instance.OvenStatus = TRUE",
          "1": "instance.HeatingElement = TRUE"
        },
        "entry_point": "BakeryOvenControl",
        "pattern_description": "If {instance.TemperatureSensor < (instance.OvenTemperature - instance.HeatingThreshold) AND instance.OvenStatus = TRUE} is true at the end of the PLC cycle, then {instance.HeatingElement = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Cooling must be active when temperature is too high",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor > (instance.OvenTemperature + instance.HeatingThreshold) AND instance.OvenStatus = TRUE",
          "1": "instance.CoolingElement = TRUE"
        },
        "entry_point": "BakeryOvenControl",
        "pattern_description": "If {instance.TemperatureSensor > (instance.OvenTemperature + instance.HeatingThreshold) AND instance.OvenStatus = TRUE} is true at the end of the PLC cycle, then {instance.CoolingElement = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "All controls must be off when oven is off",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.OvenStatus = FALSE",
          "1": "instance.HeatingElement = FALSE AND instance.CoolingElement = FALSE AND instance.HumidityControl = FALSE AND instance.DehumidityControl = FALSE"
        },
        "entry_point": "BakeryOvenControl",
        "pattern_description": "If {instance.OvenStatus = FALSE} is true at the end of the PLC cycle, then {instance.HeatingElement = FALSE AND instance.CoolingElement = FALSE AND instance.HumidityControl = FALSE AND instance.DehumidityControl = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Baking time must be valid",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.BakingTime >= T#0S"
        },
        "entry_point": "BakeryOvenControl",
        "pattern_description": "{instance.BakingTime >= T#0S} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Temperature thresholds must be positive",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.HeatingThreshold > 0.0"
        },
        "entry_point": "BakeryOvenControl",
        "pattern_description": "{instance.HeatingThreshold > 0.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "When baking completes, oven must turn off",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.BakingTime = T#0S AND instance.OvenStatus = TRUE",
          "1": "instance.OvenStatus = FALSE"
        },
        "entry_point": "BakeryOvenControl",
        "pattern_description": "If {instance.BakingTime = T#0S AND instance.OvenStatus = TRUE} is true at the end of the PLC cycle, then {instance.OvenStatus = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-43"
}

{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named TheaterControl to manage lighting and sound systems in a theater, coordinating for performances based on scene selection. The program should implement the following logic:\nStart/Stop Control:\noA StartButton initiates a performance based on the selected SceneNumber. A performance should only start if one is not already in progress.\noA StopButton immediately halts any ongoing performance, overriding any other input. When the stop button is engaged, the lighting, sound, and PerformanceInProgress output should be set to FALSE.\nScene Selection and Activation:\noThe SceneNumber input (integer) selects the desired scene.\noWhen the StartButton is pressed and no performance is in progress, the program should activate the corresponding lighting (LightingControl) and sound (SoundControl) outputs based on the selected SceneNumber.\noFor this exercise, implement a basic structure with three scenes (1, 2, and 3). For each of these valid scene numbers, set both LightingControl and SoundControl to TRUE and PerformanceInProgress to TRUE. Note: in a real-world scenario, these outputs would be controlled with more nuanced settings for each scene.\noIf an invalid SceneNumber is provided (e.g., less than 1 or greater than 3), both LightingControl and SoundControl should be set to FALSE, and PerformanceInProgress should also be set to FALSE.\nPerformance Tracking: The PerformanceInProgress output (BOOL) should be TRUE while a performance is active (after a valid scene is started and before the stop button is pressed) and FALSE otherwise.\nInputs:StartButton (BOOL), StopButton (BOOL), SceneNumber (INT).\nOutputs:LightingControl (BOOL), SoundControl (BOOL), PerformanceInProgress (BOOL).\nFUNCTION_BLOCK TheaterControl\nVAR_INPUT\n StartButton : BOOL; (* Input for starting a performance *)\n StopButton : BOOL; (* Input for stopping a performance *)\n SceneNumber : INT; (* Input for selecting the scene or act *)\nEND_VAR\nVAR_OUTPUT\n LightingControl : BOOL; (* Output for controlling lighting *)\n SoundControl : BOOL; (* Output for controlling sound *)\n PerformanceInProgress : BOOL; (* Indicator for an ongoing performance *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "When only stop button is pressed, all controls should be turned off",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton AND NOT instance.StartButton",
          "1": "NOT instance.LightingControl AND NOT instance.SoundControl AND NOT instance.PerformanceInProgress"
        },
        "entry_point": "TheaterControl",
        "pattern_description": "If {instance.StopButton AND NOT instance.StartButton} is true at the end of the PLC cycle, then {NOT instance.LightingControl AND NOT instance.SoundControl AND NOT instance.PerformanceInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When only start button is pressed with valid scene number and no performance in progress, all controls should be turned on",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.StopButton AND NOT instance.PerformanceInProgress AND instance.SceneNumber >= 1 AND instance.SceneNumber <= 3",
          "1": "instance.LightingControl AND instance.SoundControl AND instance.PerformanceInProgress"
        },
        "entry_point": "TheaterControl",
        "pattern_description": "If {instance.StartButton AND NOT instance.StopButton AND NOT instance.PerformanceInProgress AND instance.SceneNumber >= 1 AND instance.SceneNumber <= 3} is true at the end of the PLC cycle, then {instance.LightingControl AND instance.SoundControl AND instance.PerformanceInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When start button is pressed with invalid scene number, all controls should remain off",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.StopButton AND NOT instance.PerformanceInProgress AND (instance.SceneNumber < 1 OR instance.SceneNumber > 3)",
          "1": "NOT instance.LightingControl AND NOT instance.SoundControl AND NOT instance.PerformanceInProgress"
        },
        "entry_point": "TheaterControl",
        "pattern_description": "If {instance.StartButton AND NOT instance.StopButton AND NOT instance.PerformanceInProgress AND (instance.SceneNumber < 1 OR instance.SceneNumber > 3)} is true at the end of the PLC cycle, then {NOT instance.LightingControl AND NOT instance.SoundControl AND NOT instance.PerformanceInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When both start and stop buttons are pressed, no change should occur in controls",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND instance.StopButton",
          "1": "instance.LightingControl = instance.LightingControl AND instance.SoundControl = instance.SoundControl AND instance.PerformanceInProgress = instance.PerformanceInProgress"
        },
        "entry_point": "TheaterControl",
        "pattern_description": "If {instance.StartButton AND instance.StopButton} is true at the end of the PLC cycle, then {instance.LightingControl = instance.LightingControl AND instance.SoundControl = instance.SoundControl AND instance.PerformanceInProgress = instance.PerformanceInProgress} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-44"
}
{
  "instruction": "Create a function block in Structured Text (ST) that simulates the behavior of an elevator control system.\nThe system should manage the movement of the elevator between floors and handle door operations,\nbased on user input (requested position and button press). The function block should take the current position and requested position as inputs,\nand output the elevator's motor movement status and door state.\n\n\nThe function block should simulate an elevator with the following characteristics:\n\nThe elevator moves between floors based on the current position (CurrentPos) and the requested position (RequestedPos).\nThe elevator door should be closed when the elevator is moving and open when the elevator is stationary at the requested floor.\n\nWhen the button pressed (ButtonPressed), close the doll (set DoorIsOpen to false) and judge:\nIf the requested position is above the current position, the elevator should move up.\n(If RequestedPos > CurrentPos: Set MotorMovingUp = TRUE, MotorMovingDown = FALSE, and DoorIsOpen = FALSE.)\nIf the requested position is below the current position, the elevator should move down.\n(If RequestedPos < CurrentPos: Set MotorMovingUp = FALSE, MotorMovingDown = TRUE, and DoorIsOpen = FALSE.)\n\nThe elevator should stop and open the door when it reaches the requested floor.\n(When CurrentPos = RequestedPos, Set MotorMovingUp = FALSE, MotorMovingDown = FALSE, and DoorIsOpen = TRUE.)\n\nInputs:\n\nCurrentPos (INT): The current floor where the elevator is located.\nRequestedPos (INT): The target floor where the user wants the elevator to go.\nButtonPressed (BOOL): A signal indicating that the button has been pressed, triggering the elevator to start moving.\nOutputs:\n\nMotorMovingUp (BOOL): A signal indicating that the elevator motor is moving upwards.\nMotorMovingDown (BOOL): A signal indicating that the elevator motor is moving downwards.\nDoorIsOpen (BOOL): A signal indicating that the elevator door is open.\nInternal Logic:\n\nThe function block should contain internal logic to determine when the elevator motor is active (either moving up or down) or stationary.\nWhen the ButtonPressed signal is TRUE, the elevator should start moving.\nOnce the elevator reaches the RequestedPos, the motor should stop, and the door should open.\nIf the elevator is in motion, the door should be closed.\n\nOther Considerations:\n\nEnsure that the motor can only move in one direction at a time.\nThe system should be responsive to changes in the requested position while the elevator is in motion\n\n\nFUNCTION_BLOCK ElevatorControl\nVAR_INPUT\nCurrentPos : INT;\nRequestedPos : INT;\nButtonPressed : BOOL;\nEND_VAR\nVAR_OUTPUT\nMotorMovingUp : BOOL;\nMotorMovingDown : BOOL;\nDoorIsOpen : BOOL;\nEND_VAR\nVAR\nMotorStationary : BOOL := TRUE;\nEND_VAR\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that when the button is pressed, the door is closed, and the motor starts moving either up or down.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.ButtonPressed = TRUE AND instance.RequestedPos <> instance.CurrentPos",
          "2": "(instance.MotorMovingUp = TRUE OR instance.MotorMovingDown = TRUE) AND instance.DoorIsOpen = FALSE"
        },
        "pattern_description": "If {instance.ButtonPressed = TRUE AND instance.RequestedPos <> instance.CurrentPos} is true at the end of the PLC cycle, then {instance.MotorMovingUp = TRUE OR instance.MotorMovingDown = TRUE} and {instance.DoorIsOpen = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that once the elevator reaches the requested position, the motor stops and the door opens.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.CurrentPos = instance.RequestedPos",
          "2": "instance.MotorMovingUp = FALSE AND instance.MotorMovingDown = FALSE AND instance.DoorIsOpen = TRUE"
        },
        "pattern_description": "If {instance.CurrentPos = instance.RequestedPos} is true at the end of the PLC cycle, then {instance.MotorMovingUp = FALSE AND instance.MotorMovingDown = FALSE AND instance.DoorIsOpen = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the elevator does not move up and down simultaneously.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT (instance.MotorMovingUp = TRUE AND instance.MotorMovingDown = TRUE)"
        },
        "pattern_description": "{NOT (instance.MotorMovingUp = TRUE AND instance.MotorMovingDown = TRUE)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the elevator is stationary and the door is open when the current position equals the requested position.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.CurrentPos = instance.RequestedPos",
          "2": "instance.MotorMovingUp = FALSE AND instance.MotorMovingDown = FALSE AND instance.DoorIsOpen = TRUE"
        },
        "pattern_description": "{instance.CurrentPos = instance.RequestedPos AND instance.MotorMovingUp = FALSE AND instance.MotorMovingDown = FALSE AND instance.DoorIsOpen = TRUE} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-45"
}
{
  "instruction": "Design a function block in Structured Text (ST) named FB_FactorialCalculator that takes an integer input X and computes two outputs: FactorialGoodResult and FactorialResult. The function block must ensure that no overflow occurs based on the constraints of an INT type, which ranges from -32768 to 32767. Specifically:\n\nInput Constraint: If the input X is within the range of -3 to 3, calculate the factorial-like values for FactorialGoodResult and FactorialResult.\nFactorialGoodResult is calculated as X4X4, i.e., multiplying X by itself 4 times.\nFactorialResult is computed based on FactorialGoodResult:\nIf FactorialGoodResult > 1, set FactorialResult to FactorialGoodResult∗(FactorialGoodResult−1)FactorialGoodResult∗(FactorialGoodResult−1).\nOtherwise, FactorialResult equals FactorialGoodResult.\nOverflow Prevention: If X is outside the range of -3 to 3, the function block should not compute factorials and simply return FactorialResult = 1 to prevent overflow.\n\nFUNCTION_BLOCK FB_FactorialCalculator\nVAR_INPUT\nX : INT;\nEND_VAR\n\nVAR_OUTPUT\nFactorialResult : INT;\nFactorialGoodResult : INT;\nEND_VAR",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that for inputs -3 <= X <= 3, FactorialGoodResult is calculated correctly as X^4.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "(instance.X >= -3 AND instance.X <= 3)",
          "2": "instance.FactorialGoodResult = instance.X * instance.X * instance.X * instance.X"
        },
        "entry_point": "FB_FactorialCalculator",
        "pattern_description": "{(instance.FactorialGoodResult = instance.X^4)} is always true for valid X at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that if FactorialGoodResult > 1, FactorialResult is calculated as FactorialGoodResult * (FactorialGoodResult - 1).",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "(instance.X >= -3 AND instance.X <= 3) AND instance.FactorialGoodResult > 1",
          "2": "instance.FactorialResult = instance.FactorialGoodResult * (instance.FactorialGoodResult - 1)"
        },
        "entry_point": "FB_FactorialCalculator",
        "pattern_description": "If FactorialGoodResult > 1, then FactorialResult should be calculated as FactorialGoodResult * (FactorialGoodResult - 1)."
      }
    },
    {
      "property_description": "Ensure that for inputs outside the range -3 <= X <= 3, FactorialResult is set to 1 to prevent overflow.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "(instance.X < -3 OR instance.X > 3)",
          "2": "instance.FactorialResult = 1"
        },
        "entry_point": "FB_FactorialCalculator",
        "pattern_description": "If X is outside the valid range, FactorialResult should be set to 1 to prevent overflow."
      }
    }
  ],
  "id": "v2-M-46"
}
{
  "instruction": "Create a Control Logic Function Block for Signal Latching and Conditional Output\n\nObjective: Design a Function Block, named SignalControl, to handle signal latching, direct signal pass-through, and conditional output based on input values, replicating the functional behavior of the original ST code.\n\nInputs:\nEight Boolean inputs (Int1 to Int8) representing on/off control states.\nEight unsigned integer inputs (IntAn1 to IntAn8) representing analog or threshold-based inputs.\nOne Boolean input (Marca2) acting as an auxiliary control flag.\n\nOutputs:\nEight Boolean outputs (Out1 to Out8) to control external states.\nEight unsigned integer outputs (OutAn1 to OutAn8) to pass through analog or threshold values.\n\nLogic Implementation:\nFlags (Marca1, Marca2): Two internal flags, Marca1 and Marca2, are used to control the latch behavior of Out1. Marca1 and Marca2 are set or reset based on the state of each other, the input Int1, and the current state of Out1.\n\nLogic of Marca1: Marca1 is set (i.e., TRUE) when:\nMarca2 is FALSE.\nMarca1 is already TRUE (keeping it latched) or Out1 is FALSE.\nInt1 is TRUE.\n\nLogic of Marca2: Marca2 is set when:\nMarca1 is FALSE.\nMarca2 is already TRUE (keeping it latched) or Out1 is TRUE.\nInt1 is TRUE.\n\nLatch Behavior of Out1: Out1 is set based on Marca1 and Marca2, such that:\nWhen Marca2 is FALSE and either Marca1 is TRUE or Out1 is already TRUE, Out1 remains latched as TRUE.\nThis setup ensures Out1 holds its state (latched) until specific conditions trigger a reset, controlling Out1’s toggling or retention.\n\nDirect Signal Pass-Through\n\nBoolean Pass-Through: The Boolean inputs Int2, Int3, and Int4 are directly assigned to the corresponding outputs Out2, Out3, and Out4, respectively, allowing these inputs to pass through without modification.\n\nUnsigned Integer Pass-Through: The unsigned integer inputs IntAn1, IntAn2, IntAn3, and IntAn4 are directly passed to outputs OutAn1, OutAn2, OutAn3, and OutAn4, respectively, without any additional conditions.\n\nConditional Output Logic for Out5 to Out8\n\nCondition for Out5: Out5 is set to TRUE if:\nIntAn5 (an unsigned integer input) is greater than 1000.\nThe Boolean input Int5 is FALSE.\nThis ensures Out5 only activates under these specified conditions.\n\nCondition for Out6: Similarly, Out6 is set to TRUE if:\nIntAn6 is greater than 1000.\nInt6 is FALSE.\n\nCondition for Out7: Out7 is set to TRUE if:\nIntAn7 is greater than 1000.\nInt7 is FALSE.\n\nCondition for Out8: Out8 is set to TRUE if:\nIntAn8 is greater than 1000.\nInt8 is FALSE.    Output Validation: Verify that the latch mechanism maintains Out1 as expected, and check each conditional output to confirm proper activation when conditions are met.\n\nFUNCTION_BLOCK FB_SignalControl\nVAR_INPUT\nInt1 : BOOL;\nInt2 : BOOL;\nInt3 : BOOL;\nInt4 : BOOL;\nInt5 : BOOL;\nInt6 : BOOL;\nInt7 : BOOL;\nInt8 : BOOL;\nIntAn1 : UINT;\nIntAn2 : UINT;\nIntAn3 : UINT;\nIntAn4 : UINT;\nIntAn5 : UINT;\nIntAn6 : UINT;\nIntAn7 : UINT;\nIntAn8 : UINT;\nMarca2 : BOOL;\nEND_VAR_INPUT\n\nVAR_OUTPUT\nOut1 : BOOL;\nOut2 : BOOL;\nOut3 : BOOL;\nOut4 : BOOL;\nOut5 : BOOL;\nOut6 : BOOL;\nOut7 : BOOL;\nOut8 : BOOL;\nOutAn1 : UINT;\nOutAn2 : UINT;\nOutAn3 : UINT;\nOutAn4 : UINT;\nOutAn5 : UINT;\nOutAn6 : UINT;\nOutAn7 : UINT;\nOutAn8 : UINT;\nEND_VAR_OUTPUT\n\nVAR\nMarca1 : BOOL;\nGT51_OUT : BOOL;\nGT56_OUT : BOOL;\nGT57_OUT : BOOL;\nGT62_OUT : BOOL;\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that Out1 remains latched as long as the conditions in Marca1 and Marca2 are met.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.Out1 = (NOT(instance.Marca2) AND (instance.Marca1 OR instance.Out1))"
        },
        "entry_point": "FB_SignalControl",
        "pattern_description": "{instance.Out1 = (NOT(instance.Marca2) AND (instance.Marca1 OR instance.Out1))} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Verify that Out5, Out6, Out7, and Out8 only activate when the corresponding input values exceed 1000 and the associated Int inputs are FALSE.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.IntAn5 > 1000 AND NOT(instance.Int5)",
          "1": "instance.Out5 = TRUE"
        },
        "entry_point": "FB_SignalControl",
        "pattern_description": "If {instance.IntAn5 > 1000 AND NOT(instance.Int5)} is true at the end of the PLC cycle, then {instance.Out5 = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify that Out6 only activates when IntAn6 is greater than 1000 and Int6 is FALSE.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.IntAn6 > 1000 AND NOT(instance.Int6)",
          "1": "instance.Out6 = TRUE"
        },
        "entry_point": "FB_SignalControl",
        "pattern_description": "If {instance.IntAn6 > 1000 AND NOT(instance.Int6)} is true at the end of the PLC cycle, then {instance.Out6 = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify that Out7 only activates when IntAn7 is greater than 1000 and Int7 is FALSE.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.IntAn7 > 1000 AND NOT(instance.Int7)",
          "1": "instance.Out7 = TRUE"
        },
        "entry_point": "FB_SignalControl",
        "pattern_description": "If {instance.IntAn7 > 1000 AND NOT(instance.Int7)} is true at the end of the PLC cycle, then {instance.Out7 = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify that Out8 only activates when IntAn8 is greater than 1000 and Int8 is FALSE.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.IntAn8 > 1000 AND NOT(instance.Int8)",
          "1": "instance.Out8 = TRUE"
        },
        "entry_point": "FB_SignalControl",
        "pattern_description": "If {instance.IntAn8 > 1000 AND NOT(instance.Int8)} is true at the end of the PLC cycle, then {instance.Out8 = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that OutAn1, OutAn2, OutAn3, and OutAn4 pass their respective IntAn values directly without modification.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.OutAn1 = instance.IntAn1 AND instance.OutAn2 = instance.IntAn2 AND instance.OutAn3 = instance.IntAn3 AND instance.OutAn4 = instance.IntAn4"
        },
        "entry_point": "FB_SignalControl",
        "pattern_description": "{instance.OutAn1 = instance.IntAn1 AND instance.OutAn2 = instance.IntAn2 AND instance.OutAn3 = instance.IntAn3 AND instance.OutAn4 = instance.IntAn4} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-47"
}
{
  "instruction": "Implement a function block named FB_ValueOut that processes an input value based on a configuration setting.\nThe function block should have the following characteristics:\n\nInputs:\nvalueIn: INT (The input value to be processed)\nconf: UINT (Configuration setting, range 1-10)\n\nOutput:\nValueOut: INT (The processed output value)\n\n\nFunctionality:\nUse a CASE statement to handle different conf values:\n\nFor conf = 1 or 2: Divide valueIn by 10\nFor conf = 3:\n\nIf valueIn is 0, set ValueOut to 0\nIf valueIn is 300, set ValueOut to 163\nIf valueIn is 600, set ValueOut to 331\nFor any other valueIn, set ValueOut to 0\n\n\nFor conf = 6 or 7:\n\nIf valueIn is 100, set ValueOut to 319\nFor any other valueIn, set ValueOut to 0\n\n\nFor conf = 4, 5, 8, 9, 10, or any other value: Set ValueOut to 0\n\n\nEnsure that ValueOut is always an integer and non-negative.\nThe function block should be able to handle any integer input for valueIn and any unsigned integer input for conf.\n\nThis order covers all the logic present in the original ST code, including the specific value mappings and the default behavior for unspecified configurations. It also emphasizes the input and output variables and their types, which is crucial for implementing the function block correctly.\n\n\"output\": \"FUNCTION_BLOCK FB_ValueOut : INT\\nVAR_INPUT\\n    valueIn : INT;\\n    conf : UINT;\\nEND_VAR\nEND_FUNCTION_BLOCK\"",
  "properties_to_be_validated": [
    {
      "property_description": "Ensure that ValueOut is always non-negative",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "0": "instance.ValueOut >= 0"
        },
        "entry_point": "FB_ValueOut",
        "pattern_description": "{instance.ValueOut >= 0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that for conf 1 or 2, ValueOut is valueIn divided by 10",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "(instance.conf = 1 OR instance.conf = 2)",
          "1": "instance.ValueOut = instance.valueIn / 10"
        },
        "entry_point": "FB_ValueOut",
        "pattern_description": "If {(instance.conf = 1 OR instance.conf = 2)} is true at the end of the PLC cycle, then {instance.ValueOut = instance.valueIn / 10} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that for conf 3 and valueIn 300, ValueOut is 163",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.conf = 3 AND instance.valueIn = 300",
          "1": "instance.ValueOut = 163"
        },
        "entry_point": "FB_ValueOut",
        "pattern_description": "If {instance.conf = 3 AND instance.valueIn = 300} is true at the end of the PLC cycle, then {instance.ValueOut = 163} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that for conf 6 or 7 and valueIn 100, ValueOut is 319",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "(instance.conf = 6 OR instance.conf = 7) AND instance.valueIn = 100",
          "1": "instance.ValueOut = 319"
        },
        "entry_point": "FB_ValueOut",
        "pattern_description": "If {(instance.conf = 6 OR instance.conf = 7) AND instance.valueIn = 100} is true at the end of the PLC cycle, then {instance.ValueOut = 319} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that for conf 4, 5, 8, 9, or 10, ValueOut is 0",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.conf = 4 OR instance.conf = 5 OR instance.conf = 8 OR instance.conf = 9 OR instance.conf = 10 OR (instance.conf <= 0 OR instance.conf > 10)",
          "1": "instance.ValueOut = 0"
        },
        "entry_point": "FB_ValueOut",
        "pattern_description": "If {instance.conf = 4 OR instance.conf = 5 OR instance.conf = 8 OR instance.conf = 9 OR instance.conf = 10 OR (instance.conf <= 0 OR instance.conf > 10)} is true at the end of the PLC cycle, then {instance.ValueOut = 0} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-48"
}

{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named EggIncubatorControl to manage an automated egg incubator, controlling temperature, humidity, and egg turning cycles. The program should implement the following logic:\nStart/Stop Control:\noThe incubation process starts when the StartButton is pressed, provided thatIncubationInProgress is FALSE.\noThe incubation process immediately stops when the StopButton is pressed. When stopped, all outputs (HeatingElement, Humidifier, EggTurningMotor) should be turned OFF, IncubationInProgress should be set to FALSE, and TurnTimerSeconds reset to 0.\nTemperature Control:\noMaintain a TargetTemperature of 37.5 °C.\noIf the TemperatureSensor reading is less than TargetTemperature, turn the HeatingElement ON. Otherwise, turn it OFF.\nHumidity Control:\noMaintain a TargetHumidity of 50.0 %.\noIf the HumiditySensor reading is less than TargetHumidity, turn the Humidifier ON. Otherwise, turn it OFF.\nEgg Turning Cycle:\noTurn the eggs every hour (3600 seconds).\noUse a timer (TurnTimerSeconds) to track the elapsed time. When TurnTimerSeconds reaches TurnIntervalSeconds (3600), toggle the state of the EggTurningMotor (ON to OFF or OFF to ON) and reset TurnTimerSeconds to 0. This turning cycle should only operate when IncubationInProgress is TRUE.\nIncubation Status Tracking: The IncubationInProgress output (BOOL) should be TRUE when the incubation process is active (between StartButton press and StopButton press) and FALSE otherwise.\nInitialization: Initialize TargetTemperature to 37.5, TargetHumidity to 50.0, and TurnIntervalSeconds to 3600 within the function block.\nInputs:StartButton (BOOL), StopButton (BOOL), TemperatureSensor (REAL), HumiditySensor (REAL).\nOutputs:HeatingElement (BOOL), Humidifier (BOOL), EggTurningMotor (BOOL), IncubationInProgress (BOOL).\nInternal Variables:TargetTemperature (REAL), TargetHumidity (REAL), TurnIntervalSeconds (INT), TurnTimerSeconds (INT).\nFUNCTION_BLOCK EggIncubatorControl\nVAR_INPUT\n StartButton : BOOL; (* Input for starting the incubation process *)\n StopButton : BOOL; (* Input for stopping the incubation process *)\n TemperatureSensor : REAL; (* Input for temperature reading in °C *)\n HumiditySensor : REAL; (* Input for humidity reading in % *)\nEND_VAR\nVAR_OUTPUT\n HeatingElement : BOOL; (* Output for controlling the heating element *)\n Humidifier : BOOL; (* Output for controlling the humidifier *)\n EggTurningMotor : BOOL; (* Output for controlling the egg turning motor *)\n IncubationInProgress : BOOL; (* Indicator for an ongoing incubation process *)\nEND_VAR\nVAR\n TargetTemperature : REAL; (* Target temperature in °C *)\n TargetHumidity : REAL; (* Target humidity in % *)\n TurnIntervalSeconds : INT; (* Interval for turning eggs (1 hour in seconds) *)\n TurnTimerSeconds : INT; (* Timer for egg turning cycle in seconds *)\nEND_VAR\n(* Initialize control parameters *)\nTargetTemperature := 37.5;\nTargetHumidity := 50.0;\nTurnIntervalSeconds := 3600;\nTurnTimerSeconds := 0;\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "When stop button is pressed, all outputs should be turned off",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton",
          "1": "NOT instance.HeatingElement AND NOT instance.Humidifier AND NOT instance.EggTurningMotor AND NOT instance.IncubationInProgress"
        },
        "entry_point": "EggIncubatorControl",
        "pattern_description": "If {instance.StopButton} is true at the end of the PLC cycle, then {NOT instance.HeatingElement AND NOT instance.Humidifier AND NOT instance.EggTurningMotor AND NOT instance.IncubationInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When start button is pressed and no incubation in progress, all outputs should be turned on",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.IncubationInProgress AND NOT instance.StopButton",
          "1": "instance.HeatingElement AND instance.Humidifier AND instance.EggTurningMotor AND instance.IncubationInProgress"
        },
        "entry_point": "EggIncubatorControl",
        "pattern_description": "If {instance.StartButton AND NOT instance.IncubationInProgress AND NOT instance.StopButton} is true at the end of the PLC cycle, then {instance.HeatingElement AND instance.Humidifier AND instance.EggTurningMotor AND instance.IncubationInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When temperature is below target and incubation is in progress, heating element should be on",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor < 37.5 AND instance.IncubationInProgress",
          "1": "instance.HeatingElement"
        },
        "entry_point": "EggIncubatorControl",
        "pattern_description": "If {instance.TemperatureSensor < 37.5 AND instance.IncubationInProgress} is true at the end of the PLC cycle, then {instance.HeatingElement} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When humidity is below target and incubation is in progress, humidifier should be on",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.HumiditySensor < 50.0 AND instance.IncubationInProgress",
          "1": "instance.Humidifier"
        },
        "entry_point": "EggIncubatorControl",
        "pattern_description": "If {instance.HumiditySensor < 50.0 AND instance.IncubationInProgress} is true at the end of the PLC cycle, then {instance.Humidifier} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Temperature sensor value should be within realistic range (0-50°C)",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.TemperatureSensor >= 0.0 AND instance.TemperatureSensor <= 50.0"
        },
        "entry_point": "EggIncubatorControl",
        "pattern_description": "{instance.TemperatureSensor >= 0.0 AND instance.TemperatureSensor <= 50.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Humidity sensor value should be within realistic range (0-100%)",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.HumiditySensor >= 0.0 AND instance.HumiditySensor <= 100.0"
        },
        "entry_point": "EggIncubatorControl",
        "pattern_description": "{instance.HumiditySensor >= 0.0 AND instance.HumiditySensor <= 100.0} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-49"
}
{
  "instruction": "Design a PLC program using structured text (ST code) that implements a function block to Calculate Fibonacci number.\nIf the output could exceed the bound of INT (at max 32767), then return the max value of 32767 based on Saturation Arithmetic ideas.\nThis program should include a main program that initializes an integer input value NN (default is 5)\nand calculates the Fibonacci sequence up to the NN-th term.\nThe final output should be the value of the NN-th Fibonacci number.\nEnsure the program handles edge cases for NN values less than or equal to 2 correctly by returning 1.\n\nFUNCTION_BLOCK FB_Fibonacci_Calculator\nVAR_INPUT\nN : DINT := 5;\nEND_VAR\nVAR_OUTPUT\nO : DINT := 1;\nEND_VAR\nVAR\nF1 : DINT := 1;\nF2 : DINT := 1;\nCNT : DINT := 2;\nEND_VAR\n\n\n\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify that all assertions are satisfied in the program.",
      "property": {
        "job_req": "assertion"
      }
    },
    {
      "property_description": "Ensure that the output O is always a non-negative integer.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.O >= 0"
        },
        "pattern_description": "{instance.O >= 0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the output O is 1 if N is less than or equal to 2.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.N <= 2",
          "2": "instance.O = 1"
        },
        "pattern_description": "If {instance.N <= 2} is true at the end of the PLC cycle, then {instance.O = 1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the program does not enter an infinite loop.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.CNT <= instance.N"
        },
        "pattern_description": "{instance.CNT <= instance.N} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that the output O is equal to the sum of the previous two Fibonacci numbers if N is greater than 2, unless saturation occurs.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.N > 2 AND instance.O < 32767",
          "2": "instance.O = instance.F1 + instance.F2"
        },
        "pattern_description": "If {instance.N > 2 AND instance.O < 32767} is true at the end of the PLC cycle, then {instance.O = instance.F1 + instance.F2} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Ensure that the output O and intermediate values do not exceed 32767.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.O <= 32767 AND instance.F1 <= 32767 AND instance.F2 <= 32767"
        },
        "pattern_description": "{instance.O <= 32767 AND instance.F1 <= 32767 AND instance.F2 <= 32767} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Ensure that if overflow occurs, the output O is set to the maximum allowable value of 32767.",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "1": "instance.O > 32767 OR instance.O < 0",
          "2": "instance.O = 32767"
        },
        "pattern_description": "If {instance.O > 32767 OR instance.O < 0} is true at the end of the PLC cycle, then {instance.O = 32767} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-50"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named DigitalSignageManagement to manage content displayed on a network of up to 10 digital signage screens at various city locations. The program should implement the following logic:\nLocation and Content Mapping:\noUse arrays indexed from 1 to 10 to manage display locations and content.\noThe DisplayLocations input array (ARRAY[1..10] OF BOOL) indicates whether a display is active at each location. If DisplayLocations[i] is TRUE, the display at location i is considered online.\noThe ContentSource input array (ARRAY[1..10] OF INT) specifies the desired content for each location, using the following codes: \n1: News\n2: Weather\n3: Promotional Content\n0: No Content\noThe CurrentContent output array (ARRAY[1..10] OF INT) reflects the content currently being displayed at each location, using the same content codes.\nContent Assignment:\noFor each location i where DisplayLocations[i] is TRUE: \nIf ContentSource[i] is a valid content code (1, 2, or 3), assign this value directly to CurrentContent[i].\nIf ContentSource[i] is an invalid value (not 1, 2, or 3), assign 0 to CurrentContent[i] to indicate no content.\nContent Update (Simplified): The original code included a redundant timed update. This is unnecessary. The content should be updated immediately upon any change in the DisplayLocations or ContentSource inputs. Therefore, remove the timed update logic.\nInputs:DisplayLocations (ARRAY[1..10] OF BOOL), ContentSource (ARRAY[1..10] OF INT).\nOutputs:CurrentContent (ARRAY[1..10] OF INT).\nInternal Variables:RemoveContentManagementSeconds and i as they are not needed with the simplified logic.\nFUNCTION_BLOCK DigitalSignageManagement\nVAR_INPUT\n DisplayLocations : ARRAY[1..10] OF BOOL; (* Inputs for display status at various locations *)\n ContentSource : ARRAY[1..10] OF INT; (* Inputs for content sources at various locations *)\nEND_VAR\nVAR_OUTPUT\n CurrentContent : ARRAY[1..10] OF INT; (* Current content being displayed: 1=News, 2=Weather, 3=Promo, 0=None *)\nEND_VAR\nVAR\n ContentManagementSeconds : INT; (* Timer for content management in seconds *)\n i : INT; (* Loop counter *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "When a display location is active with content source 1, it must show news content (value 1)",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DisplayLocations[1] AND instance.ContentSource[1] = 1",
          "1": "instance.CurrentContent[1] = 1"
        },
        "entry_point": "DigitalSignageManagement",
        "pattern_description": "If {instance.DisplayLocations[1] AND instance.ContentSource[1] = 1} is true at the end of the PLC cycle, then {instance.CurrentContent[1] = 1} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Content source values must be within valid range (1-3)",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(NOT instance.DisplayLocations[1]) OR (instance.ContentSource[1] >= 1 AND instance.ContentSource[1] <= 3)"
        },
        "entry_point": "DigitalSignageManagement",
        "pattern_description": "{(NOT instance.DisplayLocations[1]) OR (instance.ContentSource[1] >= 1 AND instance.ContentSource[1] <= 3)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Invalid content source should display no content (value 0)",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DisplayLocations[1] AND (instance.ContentSource[1] < 1 OR instance.ContentSource[1] > 3)",
          "1": "instance.CurrentContent[1] = 0"
        },
        "entry_point": "DigitalSignageManagement",
        "pattern_description": "If {instance.DisplayLocations[1] AND (instance.ContentSource[1] < 1 OR instance.ContentSource[1] > 3)} is true at the end of the PLC cycle, then {instance.CurrentContent[1] = 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Content management timer should not exceed 60 seconds",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.ContentManagementSeconds >= 0 AND instance.ContentManagementSeconds <= 60"
        },
        "entry_point": "DigitalSignageManagement",
        "pattern_description": "{instance.ContentManagementSeconds >= 0 AND instance.ContentManagementSeconds <= 60} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Array index should always be within bounds",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.i >= 1 AND instance.i <= 10"
        },
        "entry_point": "DigitalSignageManagement",
        "pattern_description": "{instance.i >= 1 AND instance.i <= 10} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-51"
}
{
  "instruction": "Develop a PLC program in ST for a robotic welding system in an automotive assembly line. The program should control the welding process based on the status of two robot arms, a welding gun, and start/stop buttons. The welding should only be triggered if both robot arms and the welding gun are ready (RobotArm1Ready, RobotArm2Ready, WeldingGunReady are TRUE), and the start button (StartButton) is pressed. Implement a safety stop functionality: if the stop button (StopButton) is pressed at any time, the welding process should immediately stop (WeldingTrigger = FALSE, WeldingComplete = TRUE). Additionally, provide a 'WeldingComplete' output signal to indicate the completion of the welding process. The outputs are: WeldingTrigger and WeldingComplete. Ensure that WeldingComplete is set to TRUE when welding is not triggered or when the StopButton is pressed.\nFUNCTION_BLOCK RoboticWeldingSystem\nVAR_INPUT\n RobotArm1Ready : BOOL; (* Input for robot arm 1 ready status *)\n RobotArm2Ready : BOOL; (* Input for robot arm 2 ready status *)\n WeldingGunReady : BOOL; (* Input for welding gun ready status *)\n StartButton : BOOL; (* Input for start button press *)\n StopButton : BOOL; (* Input for stop button press *)\nEND_VAR\nVAR_OUTPUT\n WeldingTrigger : BOOL; (* Output to trigger welding *)\n WeldingComplete : BOOL; (* Output indicating welding completion *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Emergency stop must immediately stop welding",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton",
          "1": "NOT instance.WeldingTrigger AND instance.WeldingComplete"
        },
        "entry_point": "RoboticWeldingSystem",
        "pattern_description": "If {instance.StopButton} is true at the end of the PLC cycle, then {NOT instance.WeldingTrigger AND instance.WeldingComplete} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Welding cannot start without all systems ready",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.WeldingTrigger AND (NOT instance.RobotArm1Ready OR NOT instance.RobotArm2Ready OR NOT instance.WeldingGunReady)"
        },
        "entry_point": "RoboticWeldingSystem",
        "pattern_description": "{instance.WeldingTrigger AND (NOT instance.RobotArm1Ready OR NOT instance.RobotArm2Ready OR NOT instance.WeldingGunReady)} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "System must be either welding or complete",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "(instance.WeldingTrigger AND NOT instance.WeldingComplete) OR (NOT instance.WeldingTrigger AND instance.WeldingComplete)"
        },
        "entry_point": "RoboticWeldingSystem",
        "pattern_description": "{(instance.WeldingTrigger AND NOT instance.WeldingComplete) OR (NOT instance.WeldingTrigger AND instance.WeldingComplete)} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-52"
}
{
  "instruction": "Develop a PLC program in ST for a simplified traffic light control system managing two pairs of intersecting roads. The program should control the traffic lights based on the vehicle count at each intersection. The inputs are VehicleCount1, VehicleCount2, VehicleCount3, and VehicleCount4, representing the vehicle counts at four intersections. The outputs are TrafficLight1, TrafficLight2, TrafficLight3, and TrafficLight4, controlling the traffic lights at each intersection. When the vehicle count at one intersection is greater than the vehicle count at its corresponding intersecting intersection, the traffic light at that intersection should turn green (TRUE), and the other should turn red (FALSE). For example, if VehicleCount1 > VehicleCount2, then TrafficLight1 should be TRUE and TrafficLight2 should be FALSE. The same logic applies to VehicleCount3 and VehicleCount4, controlling TrafficLight3 and TrafficLight4, respectively. Assume that intersections 1 and 2 form one pair, and intersections 3 and 4 form another pair.\nFUNCTION_BLOCK TrafficManagementSystem\nVAR_INPUT\n VehicleCount1 : INT; (* Input for vehicle count at intersection 1 *)\n VehicleCount2 : INT; (* Input for vehicle count at intersection 2 *)\n VehicleCount3 : INT; (* Input for vehicle count at intersection 3 *)\n VehicleCount4 : INT; (* Input for vehicle count at intersection 4 *)\nEND_VAR\nVAR_OUTPUT\n TrafficLight1 : BOOL; (* Output for traffic light at intersection 1 *)\n TrafficLight2 : BOOL; (* Output for traffic light at intersection 2 *)\n TrafficLight3 : BOOL; (* Output for traffic light at intersection 3 *)\n TrafficLight4 : BOOL; (* Output for traffic light at intersection 4 *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify traffic lights are mutually exclusive for intersection pair 1-2",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.TrafficLight1 AND instance.TrafficLight2"
        },
        "entry_point": "TrafficManagementSystem",
        "pattern_description": "{instance.TrafficLight1 AND instance.TrafficLight2} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Verify traffic lights are mutually exclusive for intersection pair 3-4",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.TrafficLight3 AND instance.TrafficLight4"
        },
        "entry_point": "TrafficManagementSystem",
        "pattern_description": "{instance.TrafficLight3 AND instance.TrafficLight4} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Verify traffic light 1 activation based on vehicle count",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.VehicleCount1 > instance.VehicleCount2",
          "1": "instance.TrafficLight1 AND NOT instance.TrafficLight2"
        },
        "entry_point": "TrafficManagementSystem",
        "pattern_description": "If {instance.VehicleCount1 > instance.VehicleCount2} is true at the end of the PLC cycle, then {instance.TrafficLight1 AND NOT instance.TrafficLight2} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify traffic light 3 activation based on vehicle count",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.VehicleCount3 > instance.VehicleCount4",
          "1": "instance.TrafficLight3 AND NOT instance.TrafficLight4"
        },
        "entry_point": "TrafficManagementSystem",
        "pattern_description": "If {instance.VehicleCount3 > instance.VehicleCount4} is true at the end of the PLC cycle, then {instance.TrafficLight3 AND NOT instance.TrafficLight4} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify at least one traffic light is active in pair 1-2",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.TrafficLight1 OR instance.TrafficLight2"
        },
        "entry_point": "TrafficManagementSystem",
        "pattern_description": "{instance.TrafficLight1 OR instance.TrafficLight2} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Verify at least one traffic light is active in pair 3-4",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.TrafficLight3 OR instance.TrafficLight4"
        },
        "entry_point": "TrafficManagementSystem",
        "pattern_description": "{instance.TrafficLight3 OR instance.TrafficLight4} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-53"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) to manage an automatic home brewing system. The system should:\nMaintain a brewing temperature of 65°C using a temperature sensor and a heating element. Activate the heating element if the temperature is below 65°C and deactivate it once the target temperature is reached.\nActivate an agitation motor when the water flow, measured by a water flow sensor, is above 0.5 L/min, and deactivate it when the flow drops below this threshold.\nDispense hops after 5 hours of brewing time, based on a brewing start time and a specified brewing duration.\nInitiate the transfer to the fermentation tank after 48 hours of brewing time, using the same start time and duration as for hops dispensing.\nThe program should use input variables for temperature sensor readings, water flow sensor readings, brewing start time, and brewing duration. It should use output variables to control the heating element, agitation motor, hops dispenser, and fermentation tank transfer.\nFUNCTION_BLOCK HomeBrewingSystem\nVAR_INPUT\n TemperatureSensor : REAL; (* Input for temperature measurement (°C) *)\n WaterFlowSensor : REAL; (* Input for water flow measurement (L/min) *)\n BrewingStartTime : TIME; (* Input for brewing process start time *)\n BrewingDuration : TIME; (* Input for total brewing duration *)\nEND_VAR\nVAR_OUTPUT\n HeatingElement : BOOL; (* Output to control heating element *)\n AgitationMotor : BOOL; (* Output to control agitation motor *)\n HopsDispenser : BOOL; (* Output to control hops dispenser *)\n FermentationTank : BOOL; (* Output to control fermentation tank *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Temperature control safety check",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TemperatureSensor < 65.0",
          "1": "instance.HeatingElement"
        },
        "entry_point": "HomeBrewingSystem",
        "pattern_description": "If {instance.TemperatureSensor < 65.0} is true at the end of the PLC cycle, then {instance.HeatingElement} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Agitation motor activation consistency",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.WaterFlowSensor > 0.5",
          "1": "instance.AgitationMotor"
        },
        "entry_point": "HomeBrewingSystem",
        "pattern_description": "If {instance.WaterFlowSensor > 0.5} is true at the end of the PLC cycle, then {instance.AgitationMotor} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Hops dispensing timing verification",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.BrewingStartTime + instance.BrewingDuration > T#5h",
          "1": "instance.HopsDispenser"
        },
        "entry_point": "HomeBrewingSystem",
        "pattern_description": "If {instance.BrewingStartTime + instance.BrewingDuration > T#5h} is true at the end of the PLC cycle, then {instance.HopsDispenser} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Fermentation timing safety verification",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.BrewingStartTime + instance.BrewingDuration > T#48h",
          "1": "instance.FermentationTank"
        },
        "entry_point": "HomeBrewingSystem",
        "pattern_description": "If {instance.BrewingStartTime + instance.BrewingDuration > T#48h} is true at the end of the PLC cycle, then {instance.FermentationTank} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-54"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) to control a multimedia art installation by synchronizing audio, visual, and lighting elements based on motion detection. The program must:\n1.Input Monitoring: Detect motion using a motion sensor to initiate multimedia elements. The program should activate all elements (lighting, audio, and visuals) upon sensing motion.\n2.Element Activation: Once motion is detected, enable:\noLightingControl: Turn on lights to enhance the visual environment.\noAudioControl: Start playing the selected audio track to create an immersive experience.\noVisualControl: Activate the chosen visual content for display.\n3.Activation Timer: Implement a timer to keep track of the activation duration, ensuring that elements remain active as long as motion is detected. The timer should increment on each cycle until it reaches a predefined limit (300 seconds).\n4.Deactivate Elements: If no motion is detected, deactivate all multimedia elements. This includes turning off the lighting, stopping audio playback, and ceasing visual displays. Additionally, reset the activation timer to zero to prepare for the next motion detection event.\n5.Safety Protocols: Ensure all elements operate safely, particularly in terms of power usage and system checks, to prevent overloading and ensure longevity of all multimedia equipment.\nBy adhering to these guidelines, the multimedia art installation will effectively respond to audience presence, creating a dynamic interactive environment.\nFUNCTION_BLOCK MultimediaArtInstallationControl\nVAR_INPUT\n MotionSensor : BOOL; (* Motion detection input *)\n AudioTrack : BOOL; (* Selected audio track *)\n VisualContent : BOOL; (* Selected visual content *)\nEND_VAR\nVAR_OUTPUT\n LightingControl : BOOL; (* Lighting control output *)\n AudioControl : BOOL; (* Audio playback control *)\n VisualControl : BOOL; (* Visual display control *)\nEND_VAR\nVAR\n ActivationTimer : INT; (* Timer for activation duration *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify multimedia activation on motion detection",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.MotionSensor",
          "1": "instance.LightingControl AND instance.AudioControl AND instance.VisualControl"
        },
        "entry_point": "MultimediaArtInstallationControl",
        "pattern_description": "If {instance.MotionSensor} is true at the end of the PLC cycle, then {instance.LightingControl AND instance.AudioControl AND instance.VisualControl} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify safe deactivation when no motion",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT instance.MotionSensor",
          "1": "NOT instance.LightingControl AND NOT instance.AudioControl AND NOT instance.VisualControl"
        },
        "entry_point": "MultimediaArtInstallationControl",
        "pattern_description": "If {NOT instance.MotionSensor} is true at the end of the PLC cycle, then {NOT instance.LightingControl AND NOT instance.AudioControl AND NOT instance.VisualControl} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify activation timer limits",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.ActivationTimer < 0 OR instance.ActivationTimer > 300"
        },
        "entry_point": "MultimediaArtInstallationControl",
        "pattern_description": "{instance.ActivationTimer < 0 OR instance.ActivationTimer > 300} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Verify timer reset on deactivation",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT instance.MotionSensor",
          "1": "instance.ActivationTimer = 0"
        },
        "entry_point": "MultimediaArtInstallationControl",
        "pattern_description": "If {NOT instance.MotionSensor} is true at the end of the PLC cycle, then {instance.ActivationTimer = 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify multimedia synchronization",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.LightingControl = instance.AudioControl AND instance.AudioControl = instance.VisualControl"
        },
        "entry_point": "MultimediaArtInstallationControl",
        "pattern_description": "{instance.LightingControl = instance.AudioControl AND instance.AudioControl = instance.VisualControl} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Verify timer increment during activation",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.MotionSensor AND instance.ActivationTimer < 300 AND instance.LightingControl = FALSE"
        },
        "entry_point": "MultimediaArtInstallationControl",
        "pattern_description": "{instance.MotionSensor AND instance.ActivationTimer < 300 AND instance.LightingControl = FALSE} is impossible at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-55"
}
{
  "instruction": "Implement a PLC program in Structured Text (ST) for a modular outdoor LED lighting system that adjusts lighting based on ambient light and an energy-saving setting, with the following specifications:\nInputs:\noAmbientLight (REAL): Input from an ambient light sensor, representing the light intensity (e.g., in Lux).\noMotionSensor (BOOL): Input from a motion sensor (TRUE = Motion detected).\noEnergySaving (BOOL): Input to enable/disable energy-saving mode (TRUE = Energy saving ON).\nOutputs:\noLight (BOOL): Control output for the LED lights (TRUE = Lights ON).\noEnergyMode (BOOL): Output indicating the current energy-saving mode status (reflects the EnergySaving input).\nControl Logic:\na.Motion Detection Override: If motion is detected (MotionSensor = TRUE), the lights are turned on (Light := TRUE), and energy-saving mode is deactivated (EnergyMode := FALSE), regardless of the ambient light level or the EnergySaving input.\nb.Ambient Light and Energy Saving Control (when no motion is detected): If no motion is detected (MotionSensor = FALSE):\nIf the AmbientLight is below 50.0 (representing a low light level) AND EnergySaving is FALSE (energy-saving mode is OFF), then the lights are turned on (Light := TRUE).\nOtherwise (if AmbientLight is 50.0 or higher OR EnergySaving is TRUE), the lights are turned off (Light := FALSE).\nc.Energy Mode Status: The EnergyMode output always reflects the current state of the EnergySaving input (EnergyMode := EnergySaving).\nThe program should be implemented as a function block named OutdoorLEDLightingControl.\nFUNCTION_BLOCK OutdoorLEDLightingControl\nVAR_INPUT\n AmbientLight : REAL; (* 环境光传感器输入 *)\n MotionSensor : BOOL; (* 运动传感器输入 *)\n EnergySaving : BOOL; (* 节能模式开关 *)\nEND_VAR\nVAR_OUTPUT\n Light : BOOL; (* LED照明控制输出 *)\n EnergyMode : BOOL; (* 节能模式状态输出 *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify ambient light sensor range",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.AmbientLight < 0.0"
        },
        "entry_point": "OutdoorLEDLightingControl",
        "pattern_description": "{instance.AmbientLight < 0.0} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Verify motion sensor override",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.MotionSensor",
          "1": "instance.Light AND NOT instance.EnergyMode"
        },
        "entry_point": "OutdoorLEDLightingControl",
        "pattern_description": "If {instance.MotionSensor} is true at the end of the PLC cycle, then {instance.Light AND NOT instance.EnergyMode} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify energy saving mode behavior",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT instance.MotionSensor",
          "1": "instance.EnergyMode = instance.EnergySaving"
        },
        "entry_point": "OutdoorLEDLightingControl",
        "pattern_description": "If {NOT instance.MotionSensor} is true at the end of the PLC cycle, then {instance.EnergyMode = instance.EnergySaving} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify lighting control in bright conditions",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.AmbientLight >= 50.0 AND instance.Light AND NOT instance.MotionSensor"
        },
        "entry_point": "OutdoorLEDLightingControl",
        "pattern_description": "{instance.AmbientLight >= 50.0 AND instance.Light AND NOT instance.MotionSensor} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Verify lighting control in dark conditions",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.AmbientLight < 50.0 AND NOT instance.EnergySaving AND NOT instance.MotionSensor",
          "1": "instance.Light"
        },
        "entry_point": "OutdoorLEDLightingControl",
        "pattern_description": "If {instance.AmbientLight < 50.0 AND NOT instance.EnergySaving AND NOT instance.MotionSensor} is true at the end of the PLC cycle, then {instance.Light} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-56"
}
{
  "instruction": "Design a PLC program in ST to control a motorized retractable roof in a sports stadium, adjusting based on weather conditions. The function block receives the following inputs: RainSensor (BOOL, TRUE if rain is detected), WindSensor (BOOL, TRUE if strong wind is detected), and TemperatureSensor (REAL, current temperature). The output is RoofMotor (BOOL, TRUE closes the roof, FALSE opens the roof).\nThe control logic should operate as follows:\nCombined Rain and Wind (Highest Priority): If both RainSensor and WindSensor are TRUE (indicating both rain and strong wind), the RoofMotor output should be set to TRUE (close the roof) immediately, and the function block should exit. This condition has the highest priority.\nRain Only: If RainSensor is TRUE (indicating rain) and the combined rain and wind condition is not met, the RoofMotor output should be set to TRUE (close the roof), and the function block should exit.\nLow Temperature: If TemperatureSensor is less than 20.0 degrees and neither of the above conditions is met, the RoofMotor output should be set to TRUE (close the roof).\nNormal Conditions: If none of the above conditions are met, the RoofMotor output should be set to FALSE (open the roof).\nFUNCTION_BLOCK RetractableRoofControl\nVAR_INPUT\n RainSensor : BOOL; (* Rain detection *)\n WindSensor : BOOL; (* Wind detection *)\n TemperatureSensor : REAL; (* Temperature input *)\nEND_VAR\nVAR_OUTPUT\n RoofMotor : BOOL; (* Motor control *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify roof closes in rainy and windy conditions",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.RainSensor AND instance.WindSensor",
          "1": "NOT instance.RoofMotor"
        },
        "entry_point": "RetractableRoofControl",
        "pattern_description": "If {instance.RainSensor AND instance.WindSensor} is true at the end of the PLC cycle, then {NOT instance.RoofMotor} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify roof opens in rainy conditions without wind",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.RainSensor AND NOT instance.WindSensor",
          "1": "instance.RoofMotor"
        },
        "entry_point": "RetractableRoofControl",
        "pattern_description": "If {instance.RainSensor AND NOT instance.WindSensor} is true at the end of the PLC cycle, then {instance.RoofMotor} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify roof closes at low temperature",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT instance.RainSensor AND instance.TemperatureSensor < 20.0",
          "1": "instance.RoofMotor"
        },
        "entry_point": "RetractableRoofControl",
        "pattern_description": "If {NOT instance.RainSensor AND instance.TemperatureSensor < 20.0} is true at the end of the PLC cycle, then {instance.RoofMotor} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify roof opens in good weather",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT instance.RainSensor AND instance.TemperatureSensor >= 20.0",
          "1": "NOT instance.RoofMotor"
        },
        "entry_point": "RetractableRoofControl",
        "pattern_description": "If {NOT instance.RainSensor AND instance.TemperatureSensor >= 20.0} is true at the end of the PLC cycle, then {NOT instance.RoofMotor} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-57"
}
{
  "instruction": "Script a PLC program in ST to control a high-speed capsule filling machine in a pharmaceutical factory, ensuring accuracy and consistency. The function block receives the following inputs: CapsuleWeight (REAL, current capsule weight), TargetWeight (REAL, target weight to achieve), CapsuleInPosition (BOOL, capsule position sensor), and HopperEmpty (BOOL, hopper empty sensor). The outputs are FeederMotor (BOOL, feeder motor control), FillingMotor (BOOL, filling motor control), ConveyorMotor (BOOL, conveyor motor control), and FillingInProgress (BOOL, filling status).\nThe program logic should operate as follows:\nSafety Check (Hopper Empty): If HopperEmpty is TRUE, all motors are turned OFF, FillingInProgress is set to FALSE, and the function block execution is terminated.\nWeight Validation (Initial Check): If CapsuleWeight is greater than or equal to TargetWeight before filling starts, all motors are turned OFF, FillingInProgress is set to FALSE, and the function block execution is terminated. This avoids overfilling.\nMain Filling Control (Precise Weight Control): This is the core logic where precise weight control is implemented. The following is a general framework:\nCapsule Detection and Conveying: When CapsuleInPosition becomes TRUE, the ConveyorMotor is activated to move the capsule to the filling station.\nPrecise Filling with Feedback Control (Recommended PID): The FillingMotor is controlled using a feedback control algorithm, such as a PID controller, to achieve the TargetWeight accurately. The CapsuleWeight input provides the feedback for this control. This allows for precise adjustments during the filling process, accounting for variations in material flow.\nWeight Check During Filling: The CapsuleWeight is continuously monitored during the filling process.\nFilling Completion: When the CapsuleWeight reaches the TargetWeight (within a small tolerance), the FillingMotor is deactivated.\nConveying Out: After filling is complete, the ConveyorMotor is activated briefly to move the filled capsule out of the filling station.\nFillingInProgress is set to TRUE during the filling process and FALSE when it is completed.\nTiming and Sequencing (using Timers and State Machine Recommended): Use timers to control the duration of each stage (e.g., conveying, filling, conveyance out). A state machine can be used to manage the sequence of operations and ensure proper timing. Example states: IDLE, CONVEYING, FILLING, CONVEYING_OUT.\nDetailed Error Handling (Recommendation): Implement more specific error handling mechanisms, such as:\nCapsule Not Detected: If a capsule is not detected within a certain time after ConveyorMotor activation, set an error flag.\nFilling Timeout: If the TargetWeight is not reached within a certain time after FillingMotor activation, set an error flag.\nHopper Level Low (Preemptive): Use a low-level sensor in the hopper to provide a warning before it becomes completely empty.\nMore Realistic Filling Process(Recommendation): Consider adding more stages such as capsule orientation, separation, tamping (to compact the powder), and capsule closing.\nFUNCTION_BLOCK CapsuleFillingMachineControl\nVAR_INPUT\n CapsuleWeight : REAL; (* Current capsule weight *)\n TargetWeight : REAL; (* Target weight to achieve *)\n CapsuleInPosition : BOOL; (* Capsule position sensor *)\n HopperEmpty : BOOL; (* Hopper empty sensor *)\nEND_VAR\nVAR_OUTPUT\n FeederMotor : BOOL; (* Feeder motor control *)\n FillingMotor : BOOL; (* Filling motor control *)\n ConveyorMotor : BOOL; (* Conveyor motor control *)\n FillingInProgress : BOOL; (* Filling status *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Verify hopper empty safety response",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "1": "instance.HopperEmpty",
          "2": "NOT instance.FeederMotor AND NOT instance.FillingMotor AND NOT instance.ConveyorMotor AND NOT instance.FillingInProgress"
        },
        "entry_point": "CapsuleFillingMachineControl",
        "pattern_description": "If {instance.HopperEmpty} is true at the beginning of the PLC cycle, then {NOT instance.FeederMotor AND NOT instance.FillingMotor AND NOT instance.ConveyorMotor AND NOT instance.FillingInProgress} is always true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify target weight completion response",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CapsuleWeight >= instance.TargetWeight",
          "1": "NOT instance.FeederMotor AND NOT instance.FillingMotor AND NOT instance.ConveyorMotor AND NOT instance.FillingInProgress"
        },
        "entry_point": "CapsuleFillingMachineControl",
        "pattern_description": "If {instance.CapsuleWeight >= instance.TargetWeight} is true at the end of the PLC cycle, then {NOT instance.FeederMotor AND NOT instance.FillingMotor AND NOT instance.ConveyorMotor AND NOT instance.FillingInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify filling process activation conditions",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.FillingInProgress",
          "1": "instance.CapsuleInPosition AND NOT instance.HopperEmpty AND instance.CapsuleWeight < instance.TargetWeight AND instance.FeederMotor AND instance.FillingMotor AND instance.ConveyorMotor"
        },
        "entry_point": "CapsuleFillingMachineControl",
        "pattern_description": "If {instance.FillingInProgress} is true at the end of the PLC cycle, then {instance.CapsuleInPosition AND NOT instance.HopperEmpty AND instance.CapsuleWeight < instance.TargetWeight AND instance.FeederMotor AND instance.FillingMotor AND instance.ConveyorMotor} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify motor synchronization",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.FeederMotor OR instance.FillingMotor OR instance.ConveyorMotor",
          "1": "instance.FillingInProgress"
        },
        "entry_point": "CapsuleFillingMachineControl",
        "pattern_description": "If {instance.FeederMotor OR instance.FillingMotor OR instance.ConveyorMotor} is true at the end of the PLC cycle, then {instance.FillingInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Verify invalid operation states",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "(instance.HopperEmpty AND instance.FillingInProgress) OR (instance.CapsuleWeight >= instance.TargetWeight AND instance.FillingInProgress)"
        },
        "entry_point": "CapsuleFillingMachineControl",
        "pattern_description": "{(instance.HopperEmpty AND instance.FillingInProgress) OR (instance.CapsuleWeight >= instance.TargetWeight AND instance.FillingInProgress)} is impossible at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-58"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named DoughMixerControl to manage a bakery dough mixer. The function block should implement the following logic:\nIngredient Detection and Mixing Start:\noThe IngredientsDetected input (BOOL) signals the presence of ingredients in the mixer.\noWhen IngredientsDetected transitions from FALSE to TRUE (ingredients are detected), the MixingInProgress output (BOOL) should be immediately set to TRUE, starting the mixer. The mixing timer, MixingTimeElapsed (TIME), should be reset to T#0S at this time.\nMixing Time Limit and Automatic Stop:\noThe mixing process should continue until either: \nThe MixingTimeElapsed reaches the MixingTimeLimit (TIME), at which point MixingInProgress should be set to FALSE.\nThe IngredientsDetected input becomes FALSE (ingredients are no longer detected), at which point MixingInProgress should be set to FALSE.\noThe MixingTimeElapsed timer is incremented by T#1S in every PLC scan cycle whileMixingInProgress is TRUE.\nTimer Behavior: The MixingTimeElapsed timer only increments while mixing is in progress (MixingInProgress is TRUE). It holds its value when mixing is stopped and is reset to T#0S only when a new mixing cycle begins (when IngredientsDetected transitions to TRUE).\nMixing Time Limit Configuration: The MixingTimeLimit (TIME) should be configurable within the function block and initialized to a default value of T#5S (5 seconds).\nInputs:IngredientsDetected (BOOL)\nOutputs:MixingInProgress (BOOL)\nInternal Variables:MixingTimeElapsed (TIME), MixingTimeLimit (TIME)\nFUNCTION_BLOCK DoughMixerControl\nVAR\n IngredientsDetected : BOOL; (* Input for detecting the presence of ingredients *)\n MixingInProgress : BOOL; (* Output for controlling the mixing process - on/off *)\n MixingTimeElapsed : TIME; (* Timer to track the mixing time *)\nEND_VAR\n(* Set the mixing time duration *)\nVAR\n MixingTimeLimit : TIME := T#5S; (* Mixing time limit - 5 seconds *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Mixing should start when ingredients are detected",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.IngredientsDetected = TRUE",
          "1": "instance.MixingInProgress = TRUE"
        },
        "pattern_description": "If {instance.IngredientsDetected = TRUE} is true at the end of the PLC cycle, then {instance.MixingInProgress = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Mixing must stop when no ingredients are detected",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT instance.IngredientsDetected OR NOT instance.MixingInProgress"
        },
        "pattern_description": "{NOT instance.IngredientsDetected OR NOT instance.MixingInProgress} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Mixing should stop when time limit is reached",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT (instance.MixingTimeElapsed >= T#5S) OR (instance.MixingInProgress = FALSE)"
        },
        "pattern_description": "{NOT (instance.MixingTimeElapsed >= T#5S) OR (instance.MixingInProgress = FALSE)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Mixing time should not exceed the time limit",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.MixingTimeElapsed > T#5S"
        },
        "pattern_description": "{instance.MixingTimeElapsed > T#5S} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Timer should reset when mixing starts",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "0": "instance.IngredientsDetected = TRUE AND instance.MixingInProgress = FALSE",
          "1": "instance.MixingTimeElapsed = T#0S"
        },
        "pattern_description": "If {instance.IngredientsDetected = TRUE AND instance.MixingInProgress = FALSE} is true at the beginning of the PLC cycle, then {instance.MixingTimeElapsed = T#0S} is always true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-59"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named SolarPanelTracking to control a solar panel tracking system. The function block should implement the following logic:\nTime-Based Tracking:\noThe CurrentTime input (TIME) from the PLC's real-time clock is used for time-based tracking.\noPredefined times are used to define morning, noon, and evening: \nSunriseTime (TIME): Initialized to T#6H (6:00 AM).\nNoonTime (TIME): Initialized to T#12H (12:00 PM).\nSunsetTime (TIME): Initialized to T#18H (6:00 PM).\noThe PanelAngle output (REAL) is adjusted based on the following time periods: \nNighttime (CurrentTime < SunriseTime OR CurrentTime >= SunsetTime):PanelAngle is set to 0.0 degrees (horizontal).\nMorning (SunriseTime <= CurrentTime < NoonTime):PanelAngle is set to MorningAngle (initialized to 30.0 degrees).\nAfternoon/Evening (NoonTime <= CurrentTime < SunsetTime):PanelAngle is set to EveningAngle (initialized to 30.0 degrees). Note that at exactly NoonTime, the panel will switch to the EveningAngle.\nSolar Intensity-Based Override:\noThe SolarIntensity input (REAL) represents the measured solar intensity.\noIf SolarIntensity is greater than or equal to 90.0, the PanelAngle is immediately overridden and set to NoonAngle (initialized to 60.0 degrees), regardless of the current time. This maximizes energy capture during periods of high solar intensity.\nInitialization of Constants: The following constants should be initialized within the function block: \noSunriseTime := T#6H;\noNoonTime := T#12H;\noSunsetTime := T#18H;\noMorningAngle := 30.0;\noNoonAngle := 60.0;\noEveningAngle := 30.0;\nInputs:CurrentTime (TIME), SolarIntensity (REAL)\nOutputs:PanelAngle (REAL)\nInternal Variables:SunriseTime (TIME), NoonTime (TIME), SunsetTime (TIME), MorningAngle (REAL), NoonAngle (REAL), EveningAngle (REAL)\nFUNCTION_BLOCK SolarPanelTracking\nVAR\n PanelAngle : REAL; (* Output for adjusting the solar panel angle *)\n SunriseTime : TIME := T#6H; (* Set the time for sunrise (6:00 AM) *)\n SunsetTime : TIME := T#18H; (* Set the time for sunset (6:00 PM) *)\n NoonTime : TIME := T#12H; (* Set the time for solar noon (12:00 PM) *)\n MorningAngle : REAL := 30.0; (* Set the morning angle for panels *)\n NoonAngle : REAL := 60.0; (* Set the noon angle for panels *)\n EveningAngle : REAL := 30.0; (* Set the evening angle for panels *)\nEND_VAR\nVAR_INPUT\n CurrentTime : TIME;\n SolarIntensity : REAL;\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Panel angle must stay within safe operating range (0-90 degrees)",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.PanelAngle >= 0.0 AND instance.PanelAngle <= 90.0"
        },
        "entry_point": "SolarPanelTracking",
        "pattern_description": "{instance.PanelAngle >= 0.0 AND instance.PanelAngle <= 90.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Panels must be horizontal at night time",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CurrentTime < instance.SunriseTime OR instance.CurrentTime >= instance.SunsetTime",
          "1": "instance.PanelAngle = 0.0"
        },
        "entry_point": "SolarPanelTracking",
        "pattern_description": "If {instance.CurrentTime < instance.SunriseTime OR instance.CurrentTime >= instance.SunsetTime} is true at the end of the PLC cycle, then {instance.PanelAngle = 0.0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Morning position should be active before noon",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CurrentTime >= instance.SunriseTime AND instance.CurrentTime < instance.NoonTime AND instance.SolarIntensity < 90.0",
          "1": "instance.PanelAngle = instance.MorningAngle"
        },
        "entry_point": "SolarPanelTracking",
        "pattern_description": "If {instance.CurrentTime >= instance.SunriseTime AND instance.CurrentTime < instance.NoonTime AND instance.SolarIntensity < 90.0} is true at the end of the PLC cycle, then {instance.PanelAngle = instance.MorningAngle} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Evening position should be active after noon",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CurrentTime >= instance.NoonTime AND instance.CurrentTime < instance.SunsetTime AND instance.SolarIntensity < 90.0",
          "1": "instance.PanelAngle = instance.EveningAngle"
        },
        "entry_point": "SolarPanelTracking",
        "pattern_description": "If {instance.CurrentTime >= instance.NoonTime AND instance.CurrentTime < instance.SunsetTime AND instance.SolarIntensity < 90.0} is true at the end of the PLC cycle, then {instance.PanelAngle = instance.EveningAngle} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "High solar intensity should trigger maximum angle positioning",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.SolarIntensity >= 90.0",
          "1": "instance.PanelAngle = instance.NoonAngle"
        },
        "entry_point": "SolarPanelTracking",
        "pattern_description": "If {instance.SolarIntensity >= 90.0} is true at the end of the PLC cycle, then {instance.PanelAngle = instance.NoonAngle} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-60"
}
{
  "instruction": "Develop a PLC function block in Structured Text (ST) named PetFeederControl to manage an automatic pet feeder. The function block should implement the following logic:\nTime-Based Feeding Schedule:\noThe CurrentTime input (TIME) from the PLC's real-time clock determines when to dispense food.\noThree feeding times are defined: \nFeedTime1 (TIME): Initialized to T#8H0M0S (8:00 AM).\nFeedTime2 (TIME): Initialized to T#12H0M0S (12:00 PM).\nFeedTime3 (TIME): Initialized to T#18H0M0S (6:00 PM).\nDispensing Logic:\noThe FoodDispense output (BOOL) should be set to TRUE for 30 seconds after each of the defined feeding times. Specifically: \nIf CurrentTime is greater than or equal to FeedTime1and less than FeedTime1 + T#30S, then FoodDispense is TRUE.\nIf CurrentTime is greater than or equal to FeedTime2and less than FeedTime2 + T#30S, then FoodDispense is TRUE.\nIf CurrentTime is greater than or equal to FeedTime3and less than FeedTime3 + T#30S, then FoodDispense is TRUE.\noIn all other time periods, FoodDispense should be FALSE. This logic ensures that if the current time is during the 30 second dispensing window of multiple feeding times, the food will only be dispensed once because the conditions are evaluated.\nFood Amount (Currently Not Used): A FoodAmount variable (INT) is declared in the provided code but is currently not used in the dispensing logic. Future implementations could use this variable to control the dispensing mechanism based on a measured amount (e.g., using a metering device). For this implementation, this variable should be declared, but its function is noted as unused.\nInitialization of Constants: The following constants must be initialized inside the function block: * FeedTime1 := T#8H0M0S; * FeedTime2 := T#12H0M0S; * FeedTime3 := T#18H0M0S;\nInputs:CurrentTime (TIME)\nOutputs:FoodDispense (BOOL)\nInternal Variables:FeedTime1 (TIME), FeedTime2 (TIME), FeedTime3 (TIME), FoodAmount (INT) (Currently Unused)\nFUNCTION_BLOCK PetFeederControl\nVAR_INPUT\n CurrentTime : TIME; (* Current system time input *)\nEND_VAR\nVAR_OUTPUT\n FoodDispense : BOOL; (* Food dispenser control signal *)\nEND_VAR\nVAR\n FeedTime1 : TIME := T#8H0M0S; (* First feeding time - 8:00 AM *)\n FeedTime2 : TIME := T#12H0M0S; (* Second feeding time - 12:00 PM *)\n FeedTime3 : TIME := T#18H0M0S; (* Third feeding time - 6:00 PM *)\nEND_VAR\nVAR \n FoodAmount : INT := 50; (* Amount of food to dispense in grams *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Food dispenser should only activate during scheduled feeding times",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.FoodDispense = TRUE",
          "1": "(instance.CurrentTime >= instance.FeedTime1 AND instance.CurrentTime < instance.FeedTime1 + T#30S) OR (instance.CurrentTime >= instance.FeedTime2 AND instance.CurrentTime < instance.FeedTime2 + T#30S) OR (instance.CurrentTime >= instance.FeedTime3 AND instance.CurrentTime < instance.FeedTime3 + T#30S)"
        },
        "pattern_description": "If {instance.FoodDispense = TRUE} is true at the end of the PLC cycle, then {(instance.CurrentTime >= instance.FeedTime1 AND instance.CurrentTime < instance.FeedTime1 + T#30S) OR (instance.CurrentTime >= instance.FeedTime2 AND instance.CurrentTime < instance.FeedTime2 + T#30S) OR (instance.CurrentTime >= instance.FeedTime3 AND instance.CurrentTime < instance.FeedTime3 + T#30S)} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Food dispenser must be off outside scheduled feeding times",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.FoodDispense = TRUE AND NOT ((instance.CurrentTime >= instance.FeedTime1 AND instance.CurrentTime < instance.FeedTime1 + T#30S) OR (instance.CurrentTime >= instance.FeedTime2 AND instance.CurrentTime < instance.FeedTime2 + T#30S) OR (instance.CurrentTime >= instance.FeedTime3 AND instance.CurrentTime < instance.FeedTime3 + T#30S))"
        },
        "pattern_description": "{instance.FoodDispense = TRUE AND NOT ((instance.CurrentTime >= instance.FeedTime1 AND instance.CurrentTime < instance.FeedTime1 + T#30S) OR (instance.CurrentTime >= instance.FeedTime2 AND instance.CurrentTime < instance.FeedTime2 + T#30S) OR (instance.CurrentTime >= instance.FeedTime3 AND instance.CurrentTime < instance.FeedTime3 + T#30S))} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Food dispenser must activate at first feeding time",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CurrentTime >= instance.FeedTime1 AND instance.CurrentTime < instance.FeedTime1 + T#30S",
          "1": "instance.FoodDispense = TRUE"
        },
        "pattern_description": "If {instance.CurrentTime >= instance.FeedTime1 AND instance.CurrentTime < instance.FeedTime1 + T#30S} is true at the end of the PLC cycle, then {instance.FoodDispense = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Food dispenser must activate at second feeding time",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CurrentTime >= instance.FeedTime2 AND instance.CurrentTime < instance.FeedTime2 + T#30S",
          "1": "instance.FoodDispense = TRUE"
        },
        "pattern_description": "If {instance.CurrentTime >= instance.FeedTime2 AND instance.CurrentTime < instance.FeedTime2 + T#30S} is true at the end of the PLC cycle, then {instance.FoodDispense = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Food dispenser must activate at third feeding time",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CurrentTime >= instance.FeedTime3 AND instance.CurrentTime < instance.FeedTime3 + T#30S",
          "1": "instance.FoodDispense = TRUE"
        },
        "pattern_description": "If {instance.CurrentTime >= instance.FeedTime3 AND instance.CurrentTime < instance.FeedTime3 + T#30S} is true at the end of the PLC cycle, then {instance.FoodDispense = TRUE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-61"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named AmusementRideControl to implement a safety control system for an amusement ride. The function block should adhere to strict safety principles and implement the following logic:\nEmergency Stop (Highest Priority):\noIf the StopButton input (BOOL) is TRUE (emergency stop activated), the MotorOn output (BOOL) must be immediately set to FALSE, and the BrakeOn output (BOOL) must be immediately set to TRUE. This overrides all other conditions.\nStart Condition (All Conditions Must Be Met):\noThe MotorOn output should only be set to TRUE if all of the following conditions are met simultaneously: \nStartButton (BOOL) is TRUE.\nStopButton (BOOL) is FALSE.\nSpeedSensor (REAL) is less than or equal to SpeedLimit (REAL, initialized to 60.0 RPM).\nSafetySensor (BOOL) is TRUE (all safety interlocks are engaged).\noIf any of these conditions are not met, the MotorOn output must be FALSE, and the BrakeOn output must be TRUE.\nNormal Operation (Motor Running):\noWhile the motor is running (MotorOn is TRUE), the system continuously monitors the SpeedSensor and SafetySensor. If either the speed exceeds the SpeedLimitor the SafetySensor becomes FALSE, the MotorOn output must be immediately set to FALSE, and the BrakeOn output must be immediately set to TRUE.\nDefault State (Fail-Safe):\noThe BrakeOn output should have a default state of TRUE. This ensures that the brakes are engaged whenever the system is not actively running under safe conditions. This is a critical fail-safe measure. When neither the start nor the stop button is pressed, the brake should remain engaged.\nInitialization: The SpeedLimit should be initialized to 60.0 within the function block.\nInputs:StartButton (BOOL), StopButton (BOOL), SpeedSensor (REAL), SafetySensor (BOOL).\nOutputs:MotorOn (BOOL), BrakeOn (BOOL).\nInternal Variables:SpeedLimit (REAL).\nFUNCTION_BLOCK AmusementRideControl\nVAR_INPUT\n StartButton : BOOL; (* Start button input *)\n StopButton : BOOL; (* Emergency stop button input *)\n SpeedSensor : REAL; (* Speed sensor input (RPM) *)\n SafetySensor : BOOL; (* Safety sensor status *)\nEND_VAR\nVAR_OUTPUT\n MotorOn : BOOL := FALSE; (* Motor control output *)\n BrakeOn : BOOL := TRUE; (* Brake control output *)\nEND_VAR\nVAR\n SpeedLimit : REAL := 60.0; (* Maximum allowed speed in RPM *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Emergency stop button must immediately stop motor and engage brakes",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton = TRUE",
          "1": "instance.MotorOn = FALSE AND instance.BrakeOn = TRUE"
        },
        "pattern_description": "If {instance.StopButton = TRUE} is true at the end of the PLC cycle, then {instance.MotorOn = FALSE AND instance.BrakeOn = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Motor must not run when speed exceeds limit",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.SpeedSensor > instance.SpeedLimit AND instance.MotorOn = TRUE"
        },
        "pattern_description": "{instance.SpeedSensor > instance.SpeedLimit AND instance.MotorOn = TRUE} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Safety sensor must be active for motor operation",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.MotorOn = TRUE",
          "1": "instance.SafetySensor = TRUE"
        },
        "pattern_description": "If {instance.MotorOn = TRUE} is true at the end of the PLC cycle, then {instance.SafetySensor = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Motor and brake must not be active simultaneously",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.MotorOn = TRUE AND instance.BrakeOn = TRUE"
        },
        "pattern_description": "{instance.MotorOn = TRUE AND instance.BrakeOn = TRUE} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Motor can only start with all proper conditions met",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.MotorOn = TRUE",
          "1": "instance.StartButton = TRUE AND instance.StopButton = FALSE AND instance.SafetySensor = TRUE AND instance.SpeedSensor <= instance.SpeedLimit"
        },
        "pattern_description": "If {instance.MotorOn = TRUE} is true at the end of the PLC cycle, then {instance.StartButton = TRUE AND instance.StopButton = FALSE AND instance.SafetySensor = TRUE AND instance.SpeedSensor <= instance.SpeedLimit} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Brake must be engaged when motor is stopped",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.MotorOn = FALSE",
          "1": "instance.BrakeOn = TRUE"
        },
        "pattern_description": "If {instance.MotorOn = FALSE} is true at the end of the PLC cycle, then {instance.BrakeOn = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Motor must stop when start button is released",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton = FALSE",
          "1": "instance.MotorOn = FALSE"
        },
        "pattern_description": "If {instance.StartButton = FALSE} is true at the end of the PLC cycle, then {instance.MotorOn = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-62"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) to implement a parcel sorting system that utilizes sensors to determine parcel size and destination, controlling a conveyor belt motor and two sorting gates to direct parcels to their appropriate destinations. The program should take input from a parcel size sensor, which measures the size of the parcel, and a destination code sensor, which identifies the parcel's destination (with codes such as 1 for location A and 2 for location B). Based on the size and destination code, the control logic should activate the conveyor belt motor and adjust the sorting gates accordingly: large parcels should be routed to sorting gate 1, small parcels destined for location A should be routed to sorting gate 2, and small parcels destined for location B should remain on the conveyor belt without activating any sorting gates. If the parcel size or destination code is invalid, the program should stop the conveyor belt and close both sorting gates to prevent errors in the sorting process. The implementation should ensure that all control outputs are clearly defined and logically updated based on sensor inputs, with appropriate initialization and default states to handle scenarios where no valid parcels are detected. Clear and descriptive variable names should be used throughout the program, and comments should be included to enhance readability, maintainability, and facilitate any future adjustments to the sorting logic or thresholds.\nFUNCTION_BLOCK ParcelSortingSystem\nVAR_INPUT\n ParcelSizeSensor : REAL; (* Sensor input for parcel size *)\n DestinationCodeSensor : INT; (* Destination code: 1=A, 2=B *)\nEND_VAR\nVAR_OUTPUT\n ConveyorBeltMotor : BOOL; (* Output for conveyor belt motor: TRUE=On, FALSE=Off *)\n SortingGate1 : BOOL; (* Output for sorting gate 1: TRUE=Open, FALSE=Closed *)\n SortingGate2 : BOOL; (* Output for sorting gate 2: TRUE=Open, FALSE=Closed *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Sorting gates cannot be open simultaneously",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "instance.SortingGate1 = TRUE AND instance.SortingGate2 = TRUE"
        },
        "entry_point": "ParcelSortingSystem",
        "pattern_description": "{instance.SortingGate1 = TRUE AND instance.SortingGate2 = TRUE} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Large parcels must be routed to Gate 1",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ParcelSizeSensor > 0.5",
          "1": "instance.SortingGate1 = TRUE AND instance.SortingGate2 = FALSE"
        },
        "entry_point": "ParcelSortingSystem",
        "pattern_description": "If {instance.ParcelSizeSensor > 0.5} is true at the end of the PLC cycle, then {instance.SortingGate1 = TRUE AND instance.SortingGate2 = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Small parcels for destination A must be routed to Gate 2",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ParcelSizeSensor <= 0.5 AND instance.DestinationCodeSensor = 1",
          "1": "instance.SortingGate1 = FALSE AND instance.SortingGate2 = TRUE"
        },
        "entry_point": "ParcelSortingSystem",
        "pattern_description": "If {instance.ParcelSizeSensor <= 0.5 AND instance.DestinationCodeSensor = 1} is true at the end of the PLC cycle, then {instance.SortingGate1 = FALSE AND instance.SortingGate2 = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Small parcels for destination B must be routed to conveyor",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ParcelSizeSensor <= 0.5 AND instance.DestinationCodeSensor = 2",
          "1": "instance.SortingGate1 = FALSE AND instance.SortingGate2 = FALSE"
        },
        "entry_point": "ParcelSortingSystem",
        "pattern_description": "If {instance.ParcelSizeSensor <= 0.5 AND instance.DestinationCodeSensor = 2} is true at the end of the PLC cycle, then {instance.SortingGate1 = FALSE AND instance.SortingGate2 = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Conveyor must run when valid parcel is detected",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "(instance.ParcelSizeSensor > 0.5) OR (instance.ParcelSizeSensor <= 0.5 AND (instance.DestinationCodeSensor = 1 OR instance.DestinationCodeSensor = 2))",
          "1": "instance.ConveyorBeltMotor = TRUE"
        },
        "entry_point": "ParcelSortingSystem",
        "pattern_description": "If {(instance.ParcelSizeSensor > 0.5) OR (instance.ParcelSizeSensor <= 0.5 AND (instance.DestinationCodeSensor = 1 OR instance.DestinationCodeSensor = 2))} is true at the end of the PLC cycle, then {instance.ConveyorBeltMotor = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Invalid parcels must stop system",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ParcelSizeSensor <= 0.5 AND instance.DestinationCodeSensor <> 1 AND instance.DestinationCodeSensor <> 2",
          "1": "instance.ConveyorBeltMotor = FALSE AND instance.SortingGate1 = FALSE AND instance.SortingGate2 = FALSE"
        },
        "entry_point": "ParcelSortingSystem",
        "pattern_description": "If {instance.ParcelSizeSensor <= 0.5 AND instance.DestinationCodeSensor <> 1 AND instance.DestinationCodeSensor <> 2} is true at the end of the PLC cycle, then {instance.ConveyorBeltMotor = FALSE AND instance.SortingGate1 = FALSE AND instance.SortingGate2 = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-63"
}
{
  "instruction": "Create a PLC program in Structured Text (ST) to control an industrial shredder with the following logic and safety features:\nEmergency Stop and Jam Detection: The shredder motor must stop immediately and a safety relay must be deactivated if either an emergency stop button is pressed or a jam is detected by a sensor. These conditions have the highest priority.\nNormal Operation:\noA start button initiates the shredder motor.\noA stop button stops the shredder motor under normal conditions.\noThe shredder motor should also start automatically when material is being fed into the shredder.\nSafety Relay: A safety relay must be active (TRUE) during normal operation (when the motor is running or ready to run) and deactivated (FALSE) during emergency stop or jam conditions.\nInputs:StartButton (BOOL), StopButton (BOOL), EmergencyStop (BOOL), MaterialInFeed (BOOL), JammedSensor (BOOL).\nOutputs:MotorControl (BOOL) to control the shredder motor, SafetyRelay (BOOL) for the safety relay.\nImplement this logic within a function block named ShredderControl.\nFUNCTION_BLOCK ShredderControl\nVAR_INPUT\n StartButton : BOOL; (* Input for the start button *)\n StopButton : BOOL; (* Input for the stop button *)\n EmergencyStop : BOOL; (* Input for the emergency stop button *)\n MotorStatus : BOOL; (* Feedback status of the shredder motor *)\n MaterialInFeed : BOOL; (* Input for material being fed into the shredder *)\n JammedSensor : BOOL; (* Input for detecting material jamming *)\nEND_VAR\nVAR_OUTPUT\n MotorControl : BOOL; (* Output for controlling the shredder motor *)\n SafetyRelay : BOOL; (* Output for safety relay: TRUE=Safe, FALSE=Unsafe *)\nEND_VAR\n(* Initialize outputs *)\nMotorControl := FALSE;\nSafetyRelay := FALSE;\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Emergency stop must immediately stop the motor and set safety relay to unsafe regardless of other conditions",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EmergencyStop",
          "1": "instance.MotorControl = FALSE AND instance.SafetyRelay = FALSE"
        },
        "entry_point": "ShredderControl",
        "pattern_description": "If {instance.EmergencyStop} is true at the end of the PLC cycle, then {instance.MotorControl = FALSE AND instance.SafetyRelay = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Material jam must stop the motor and set safety relay to unsafe if emergency stop is not active",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.JammedSensor AND NOT instance.EmergencyStop",
          "1": "instance.MotorControl = FALSE AND instance.SafetyRelay = FALSE"
        },
        "entry_point": "ShredderControl",
        "pattern_description": "If {instance.JammedSensor AND NOT instance.EmergencyStop} is true at the end of the PLC cycle, then {instance.MotorControl = FALSE AND instance.SafetyRelay = FALSE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Stop button must stop the motor and keep safety relay safe if no emergency conditions exist",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton AND NOT instance.EmergencyStop AND NOT instance.JammedSensor",
          "1": "instance.MotorControl = FALSE AND instance.SafetyRelay = TRUE"
        },
        "entry_point": "ShredderControl",
        "pattern_description": "If {instance.StopButton AND NOT instance.EmergencyStop AND NOT instance.JammedSensor} is true at the end of the PLC cycle, then {instance.MotorControl = FALSE AND instance.SafetyRelay = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Start button can only start motor if no emergency or stop conditions exist",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.EmergencyStop AND NOT instance.JammedSensor AND NOT instance.StopButton",
          "1": "instance.MotorControl = TRUE AND instance.SafetyRelay = TRUE"
        },
        "entry_point": "ShredderControl",
        "pattern_description": "If {instance.StartButton AND NOT instance.EmergencyStop AND NOT instance.JammedSensor AND NOT instance.StopButton} is true at the end of the PLC cycle, then {instance.MotorControl = TRUE AND instance.SafetyRelay = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Material feed should start the motor only if no emergency, stop or jam conditions exist",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.MaterialInFeed AND NOT instance.EmergencyStop AND NOT instance.JammedSensor AND NOT instance.StopButton",
          "1": "instance.MotorControl = TRUE AND instance.SafetyRelay = TRUE"
        },
        "entry_point": "ShredderControl",
        "pattern_description": "If {instance.MaterialInFeed AND NOT instance.EmergencyStop AND NOT instance.JammedSensor AND NOT instance.StopButton} is true at the end of the PLC cycle, then {instance.MotorControl = TRUE AND instance.SafetyRelay = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Safety relay must be FALSE when motor is not running and emergency conditions exist",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT instance.MotorControl AND (instance.EmergencyStop OR instance.JammedSensor)",
          "1": "instance.SafetyRelay = FALSE"
        },
        "entry_point": "ShredderControl",
        "pattern_description": "If {NOT instance.MotorControl AND (instance.EmergencyStop OR instance.JammedSensor)} is true at the end of the PLC cycle, then {instance.SafetyRelay = FALSE} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-64"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named FruitJuicingBottling to control an automated fruit juicing and bottling line. The program should implement the following logic:\nStart/Stop Control:\noThe process begins when the StartButton is pressed, provided that the FruitSelected input is TRUE and the ProcessInProgress output is FALSE (meaning no process is currently running).\noThe process immediately stops if the StopButton is pressed or if the FruitSelected input becomes FALSE during operation.\nProcess Stages (Concurrent Implementation):\noOnce the start conditions are met, the following operations should occur simultaneously: \nJuiceProcessing (controls juice extraction).\nBottleFilling (controls bottle filling).\nCapPlacement (controls cap placement).\nPackaging (controls packaging).\noNote: This is a simplified implementation where all stages occur concurrently. In a real-world scenario, these stages would likely be sequential with interlocks and sensors to ensure proper timing and coordination.\nProcess Tracking: The ProcessInProgress output (BOOL) should be TRUE while the process is running (after the start conditions are met and before a stop condition occurs) and FALSE otherwise.\nInputs:StartButton (BOOL), StopButton (BOOL), FruitSelected (BOOL).\nOutputs:JuiceProcessing (BOOL), BottleFilling (BOOL), CapPlacement (BOOL), Packaging (BOOL), ProcessInProgress (BOOL).\nFUNCTION_BLOCK FruitJuicingBottling\nVAR_INPUT\n StartButton : BOOL; (* Input for starting the process *)\n StopButton : BOOL; (* Input for stopping the process *)\n FruitSelected : BOOL; (* Input indicating fruit selection *)\nEND_VAR\nVAR_OUTPUT\n JuiceProcessing : BOOL; (* Output for controlling juice extraction *)\n BottleFilling : BOOL; (* Output for controlling bottle filling *)\n CapPlacement : BOOL; (* Output for placing caps on bottles *)\n Packaging : BOOL; (* Output for packaging filled bottles *)\n ProcessInProgress : BOOL; (* Indicator for an ongoing process *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "When stop button is pressed, all processes should be stopped",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton",
          "1": "NOT instance.JuiceProcessing AND NOT instance.BottleFilling AND NOT instance.CapPlacement AND NOT instance.Packaging AND NOT instance.ProcessInProgress"
        },
        "entry_point": "FruitJuicingBottling",
        "pattern_description": "If {instance.StopButton} is true at the end of the PLC cycle, then {NOT instance.JuiceProcessing AND NOT instance.BottleFilling AND NOT instance.CapPlacement AND NOT instance.Packaging AND NOT instance.ProcessInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When start conditions are met, juice processing should start",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.ProcessInProgress AND instance.FruitSelected AND NOT instance.StopButton",
          "1": "instance.JuiceProcessing"
        },
        "entry_point": "FruitJuicingBottling",
        "pattern_description": "If {instance.StartButton AND NOT instance.ProcessInProgress AND instance.FruitSelected AND NOT instance.StopButton} is true at the end of the PLC cycle, then {instance.JuiceProcessing} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When juice processing starts, bottle filling should also start",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.JuiceProcessing",
          "1": "instance.BottleFilling"
        },
        "entry_point": "FruitJuicingBottling",
        "pattern_description": "If {instance.JuiceProcessing} is true at the end of the PLC cycle, then {instance.BottleFilling} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When bottle filling starts, cap placement should also start",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.BottleFilling",
          "1": "instance.CapPlacement"
        },
        "entry_point": "FruitJuicingBottling",
        "pattern_description": "If {instance.BottleFilling} is true at the end of the PLC cycle, then {instance.CapPlacement} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When cap placement starts, packaging should also start",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.CapPlacement",
          "1": "instance.Packaging"
        },
        "entry_point": "FruitJuicingBottling",
        "pattern_description": "If {instance.CapPlacement} is true at the end of the PLC cycle, then {instance.Packaging} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When any process is running, ProcessInProgress should be true",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.JuiceProcessing OR instance.BottleFilling OR instance.CapPlacement OR instance.Packaging",
          "1": "instance.ProcessInProgress"
        },
        "entry_point": "FruitJuicingBottling",
        "pattern_description": "If {instance.JuiceProcessing OR instance.BottleFilling OR instance.CapPlacement OR instance.Packaging} is true at the end of the PLC cycle, then {instance.ProcessInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Process cannot start without fruit selection",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "NOT instance.FruitSelected AND instance.ProcessInProgress"
        },
        "entry_point": "FruitJuicingBottling",
        "pattern_description": "{NOT instance.FruitSelected AND instance.ProcessInProgress} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "All processes must be active together when process is in progress",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.ProcessInProgress",
          "1": "instance.JuiceProcessing AND instance.BottleFilling AND instance.CapPlacement AND instance.Packaging"
        },
        "entry_point": "FruitJuicingBottling",
        "pattern_description": "If {instance.ProcessInProgress} is true at the end of the PLC cycle, then {instance.JuiceProcessing AND instance.BottleFilling AND instance.CapPlacement AND instance.Packaging} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Stop button should take precedence over start button",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton AND instance.StartButton",
          "1": "NOT instance.ProcessInProgress"
        },
        "entry_point": "FruitJuicingBottling",
        "pattern_description": "If {instance.StopButton AND instance.StartButton} is true at the end of the PLC cycle, then {NOT instance.ProcessInProgress} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-65"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named WaterDesalination to manage a simplified water desalination process. The program should implement the following logic:\nStart/Stop Control:\noWhen the StartButton is pressed andDesalinationInProgress is FALSE, the desalination process begins: both the SeawaterInletValve and the FreshwaterOutletValve open, and DesalinationInProgress is set to TRUE.\noWhen the StopButton is pressed, the desalination process immediately stops: both valves close, DesalinationInProgress is set to FALSE, and SalinityControlSeconds is reset to 0.\nSalinity Monitoring and Control:\noThe SalinitySensor input (REAL) provides real-time salinity readings.\noThe maximum acceptable salinity for freshwater (MaxSalinity) is set to 35.0.\noEvery 10 seconds, the program checks the SalinitySensor reading. If the reading is greater than MaxSalinity, the FreshwaterOutletValve closes to prevent the output of excessively salty water. If the reading is less than or equal to MaxSalinity, the FreshwaterOutletValve remains open. A timer (SalinityControlSeconds) is used to implement the 10-second check interval.\nProcess Tracking: The DesalinationInProgress output (BOOL) indicates whether the desalination process is currently active.\nInitialization: Initialize MaxSalinity to 35.0 within the function block.\nInputs:StartButton (BOOL), StopButton (BOOL), SalinitySensor (REAL).\nOutputs:SeawaterInletValve (BOOL), FreshwaterOutletValve (BOOL), DesalinationInProgress (BOOL).\nInternal Variables:MaxSalinity (REAL), SalinityControlSeconds (INT).\nFUNCTION_BLOCK WaterDesalination\nVAR_INPUT\n StartButton : BOOL; (* Input for starting the desalination process *)\n StopButton : BOOL; (* Input for stopping the desalination process *)\n SalinitySensor : REAL; (* Input for salinity level measurement *)\nEND_VAR\nVAR_OUTPUT\n SeawaterInletValve : BOOL; (* Output for seawater inlet valve control *)\n FreshwaterOutletValve : BOOL; (* Output for freshwater outlet valve control *)\n DesalinationInProgress : BOOL; (* Indicator for an ongoing desalination process *)\nEND_VAR\nVAR\n MaxSalinity : REAL := 35.0; (* Maximum allowable salinity in ppm for freshwater *)\n SalinityControlSeconds : INT := 0; (* Timer for salinity control in seconds *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "When stop button is pressed, all outputs should be turned off",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton",
          "1": "NOT instance.SeawaterInletValve AND NOT instance.FreshwaterOutletValve AND NOT instance.DesalinationInProgress"
        },
        "entry_point": "WaterDesalination",
        "pattern_description": "If {instance.StopButton} is true at the end of the PLC cycle, then {NOT instance.SeawaterInletValve AND NOT instance.FreshwaterOutletValve AND NOT instance.DesalinationInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When start button is pressed and no process in progress, all valves should open",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.DesalinationInProgress AND NOT instance.StopButton",
          "1": "instance.SeawaterInletValve AND instance.FreshwaterOutletValve AND instance.DesalinationInProgress"
        },
        "entry_point": "WaterDesalination",
        "pattern_description": "If {instance.StartButton AND NOT instance.DesalinationInProgress AND NOT instance.StopButton} is true at the end of the PLC cycle, then {instance.SeawaterInletValve AND instance.FreshwaterOutletValve AND instance.DesalinationInProgress} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When salinity exceeds maximum level during operation, freshwater outlet valve should close",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DesalinationInProgress AND instance.SalinitySensor > 35.0",
          "1": "NOT instance.FreshwaterOutletValve"
        },
        "entry_point": "WaterDesalination",
        "pattern_description": "If {instance.DesalinationInProgress AND instance.SalinitySensor > 35.0} is true at the end of the PLC cycle, then {NOT instance.FreshwaterOutletValve} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When salinity is within acceptable range during operation, freshwater outlet valve should open",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.DesalinationInProgress AND instance.SalinitySensor <= 35.0",
          "1": "instance.FreshwaterOutletValve"
        },
        "entry_point": "WaterDesalination",
        "pattern_description": "If {instance.DesalinationInProgress AND instance.SalinitySensor <= 35.0} is true at the end of the PLC cycle, then {instance.FreshwaterOutletValve} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Salinity sensor value should be within realistic range (0-100 ppm)",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.SalinitySensor >= 0.0 AND instance.SalinitySensor <= 100.0"
        },
        "entry_point": "WaterDesalination",
        "pattern_description": "{instance.SalinitySensor >= 0.0 AND instance.SalinitySensor <= 100.0} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-66"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named SmartLockerControl to manage access and security for a system of 10 smart lockers in a public space. The program should implement the following logic:\nLocker Management:\noUse arrays indexed from 1 to 10 to manage the lockers.\noThe LockerStatus array (ARRAY[1..10] OF BOOL) tracks the status of each locker: TRUE indicates the locker is occupied (locked), and FALSE indicates it is empty (unlocked). Initially, all lockers should be set to TRUE (locked).\noThe LockerAccessCode array (ARRAY[1..10] OF INT) stores the unique access code for each locker. Initialize the access codes as follows: \nLocker 1: 1234\nLocker 2: 5678\nLocker 3: 9876\nLocker 4: 4321\nLocker 5: 6543\nLocker 6: 7890\nLocker 7: 3456\nLocker 8: 8765\nLocker 9: 2345\nLocker 10: 6789\nAccess Control Logic:\noThe LockerNumber input (INT) specifies the locker the user wishes to access. The program should only proceed if this number is within the valid range of 1 to 10.\noThe AccessCode input (INT) is the code entered by the user.\noIf the LockerNumber is valid and the AccessCode matches the corresponding LockerAccessCode[LockerNumber], the LockerOpen output (BOOL) should be set to TRUE to open the locker.\noAfter successfully opening a locker, the LockerStatus[LockerNumber] should be updated to FALSE to indicate that the locker is now empty.\nInitialization: Initialize the LockerAccessCode and LockerStatus arrays as specified above within the function block.\nOutputs:LockerOpen (BOOL).\nInputs:AccessCode (INT), LockerNumber (INT).\nInternal Variables:LockerStatus (ARRAY[1..10] OF BOOL), LockerAccessCode (ARRAY[1..10] OF INT), i (INT).\nFUNCTION_BLOCK SmartLockerControl\nVAR_INPUT\n AccessCode : INT; (* Input for user access code *)\n LockerNumber : INT; (* Input for selected locker number *)\nEND_VAR\nVAR_OUTPUT\n LockerOpen : BOOL; (* Output to control locker door *)\nEND_VAR\nVAR\n LockerStatus : ARRAY[1..10] OF BOOL; (* Status of individual lockers: TRUE=locked, FALSE=empty *)\n LockerAccessCode : ARRAY[1..10] OF INT;(* Locker access codes *)\n i : INT; (* Loop counter *)\nEND_VAR\n(* Initialize access codes *)\nLockerAccessCode[1] := 1234;\nLockerAccessCode[2] := 5678;\nLockerAccessCode[3] := 9876;\nLockerAccessCode[4] := 4321;\nLockerAccessCode[5] := 6543;\nLockerAccessCode[6] := 7890;\nLockerAccessCode[7] := 3456;\nLockerAccessCode[8] := 8765;\nLockerAccessCode[9] := 2345;\nLockerAccessCode[10] := 6789;\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "When locker number is invalid, locker should not open",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.LockerNumber < 1 OR instance.LockerNumber > 10",
          "1": "NOT instance.LockerOpen"
        },
        "entry_point": "SmartLockerControl",
        "pattern_description": "If {instance.LockerNumber < 1 OR instance.LockerNumber > 10} is true at the end of the PLC cycle, then {NOT instance.LockerOpen} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When access code is correct and locker is locked, locker should open",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.LockerNumber >= 1 AND instance.LockerNumber <= 10 AND instance.AccessCode = 1234 AND instance.LockerNumber = 1",
          "1": "instance.LockerOpen"
        },
        "entry_point": "SmartLockerControl",
        "pattern_description": "If {instance.LockerNumber >= 1 AND instance.LockerNumber <= 10 AND instance.AccessCode = 1234 AND instance.LockerNumber = 1} is true at the end of the PLC cycle, then {instance.LockerOpen} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When access code is incorrect, locker should remain closed",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.LockerNumber >= 1 AND instance.LockerNumber <= 10 AND instance.AccessCode <> 1234 AND instance.LockerNumber = 1",
          "1": "NOT instance.LockerOpen"
        },
        "entry_point": "SmartLockerControl",
        "pattern_description": "If {instance.LockerNumber >= 1 AND instance.LockerNumber <= 10 AND instance.AccessCode <> 1234 AND instance.LockerNumber = 1} is true at the end of the PLC cycle, then {NOT instance.LockerOpen} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Locker number should always be within valid range",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT instance.LockerOpen OR (instance.LockerNumber >= 1 AND instance.LockerNumber <= 10)"
        },
        "entry_point": "SmartLockerControl",
        "pattern_description": "{NOT instance.LockerOpen OR (instance.LockerNumber >= 1 AND instance.LockerNumber <= 10)} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Access code should be a positive integer",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.AccessCode >= 0"
        },
        "entry_point": "SmartLockerControl",
        "pattern_description": "{instance.AccessCode >= 0} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-67"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named SoilTestingDeviceControl to simulate an automated soil testing device for agricultural analysis of nutrients and pH. The function block should implement the following logic:\nTesting Status Management (State Machine):\noThe TestingStatus variable (INT) manages the state of the testing process: \n0: Idle (Initial state)\n1: Testing\n2: Completed\nInitialization:\noWhen TestingStatus is 0 (Idle), initialize the simulated sensor values: \npHSensorValue (REAL) := 7.0;\nNutrientSensorValue (REAL) := 0.5;\nStart/Testing Logic:\noStart: When the StartButton input (BOOL) is TRUE andTestingStatus is 0 (Idle), the TestingStatus transitions to 1 (Testing), and both pumps are activated: \nNutrientPump (BOOL) := TRUE;\npHAdjustmentPump (BOOL) := TRUE;\noSample Detection and Analysis: When SoilSampleDetected (BOOL) becomes TRUE andTestingStatus is 1 (Testing): \nThe system checks if both conditions are met: \nNutrientSensorValue is greater than or equal to NutrientThreshold (REAL, initialized to 0.7).\npHSensorValue is less than or equal to pHThreshold (REAL, initialized to 6.5).\nIf both conditions are met, the TestingStatus transitions to 2 (Completed), and both pumps are deactivated: \nNutrientPump := FALSE;\npHAdjustmentPump := FALSE;\nSimulated Sensor Value Updates (During Testing):\noWhile TestingStatus is 1 (Testing), the simulated sensor values are updated in each scan cycle to simulate a testing process: \nNutrientSensorValue is incremented by 0.1, but it does not exceed 0.9.\npHSensorValue is decremented by 0.5, but it does not go below 4.0.\nInputs:StartButton (BOOL), SoilSampleDetected (BOOL)\nOutputs:NutrientPump (BOOL), pHAdjustmentPump (BOOL)\nInternal Variables:pHSensorValue (REAL), NutrientSensorValue (REAL), TestingStatus (INT), NutrientThreshold (REAL), pHThreshold (REAL)\nFUNCTION_BLOCK SoilTestingDeviceControl\nVAR_INPUT\n StartButton : BOOL; (* Input for starting the testing process *)\n SoilSampleDetected : BOOL; (* Input for detecting soil sample *)\nEND_VAR\nVAR_OUTPUT\n NutrientPump : BOOL; (* Output to control nutrient pump *)\n pHAdjustmentPump : BOOL; (* Output to control pH adjustment pump *)\nEND_VAR\nVAR\n pHSensorValue : REAL; (* Simulated pH sensor value *)\n NutrientSensorValue : REAL; (* Simulated nutrient sensor value *)\n TestingStatus : INT; (* Status: 0=Idle, 1=Testing, 2=Completed *)\n NutrientThreshold : REAL := 0.7; (* Nutrient level threshold for analysis *)\n pHThreshold : REAL := 6.5; (* pH level threshold for analysis *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "When start button is pressed in idle state, pumps should start",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND instance.TestingStatus = 0",
          "1": "instance.NutrientPump AND instance.pHAdjustmentPump"
        },
        "entry_point": "SoilTestingDeviceControl",
        "pattern_description": "If {instance.StartButton AND instance.TestingStatus = 0} is true at the end of the PLC cycle, then {instance.NutrientPump AND instance.pHAdjustmentPump} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "When testing completes successfully, pumps should stop",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.TestingStatus = 2",
          "1": "NOT instance.NutrientPump AND NOT instance.pHAdjustmentPump"
        },
        "entry_point": "SoilTestingDeviceControl",
        "pattern_description": "If {instance.TestingStatus = 2} is true at the end of the PLC cycle, then {NOT instance.NutrientPump AND NOT instance.pHAdjustmentPump} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "pH sensor value should always be within valid range",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.pHSensorValue >= 4.0 AND instance.pHSensorValue <= 8.0"
        },
        "entry_point": "SoilTestingDeviceControl",
        "pattern_description": "{instance.pHSensorValue >= 4.0 AND instance.pHSensorValue <= 8.0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Nutrient sensor value should never be below minimum threshold",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.NutrientSensorValue >= 0.2"
        },
        "entry_point": "SoilTestingDeviceControl",
        "pattern_description": "{instance.NutrientSensorValue >= 0.2} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "When soil sample is detected and nutrient level is below threshold, nutrient pump should be active",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.SoilSampleDetected AND instance.NutrientSensorValue < instance.NutrientThreshold AND instance.TestingStatus = 1",
          "1": "instance.NutrientPump"
        },
        "entry_point": "SoilTestingDeviceControl",
        "pattern_description": "If {instance.SoilSampleDetected AND instance.NutrientSensorValue < instance.NutrientThreshold AND instance.TestingStatus = 1} is true at the end of the PLC cycle, then {instance.NutrientPump} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Testing status should be within valid range (0-2)",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.TestingStatus >= 0 AND instance.TestingStatus <= 2"
        },
        "entry_point": "SoilTestingDeviceControl",
        "pattern_description": "{instance.TestingStatus >= 0 AND instance.TestingStatus <= 2} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-68"
}
{
  "instruction": "Develop a PLC program in Structured Text (ST) within a function block named SushiConveyorControl to simulate the control of an automated sushi conveyor belt. The function block should implement the following logic:\nEmergency Stop (Highest Priority):\noIf the EmergencyStop input (BOOL) is TRUE, the ConveyorMotor output (BOOL) is immediately set to FALSE, the BeltRunning variable (BOOL) is set to FALSE, and the ConveyorTimer variable (INT) is reset to 0. The function block then immediately exits using the RETURN statement. This ensures the highest priority for emergency stops.\nStart/Stop Control:\noStart: If the StartButton input (BOOL) is TRUE and the BeltRunning variable is FALSE (conveyor is not already running), the ConveyorMotor output is set to TRUE, the BeltRunning variable is set to TRUE, and the ConveyorTimer is reset to 0.\noStop: If the StopButton input (BOOL) is TRUE and the BeltRunning variable is TRUE (conveyor is running), the ConveyorMotor output is set to FALSE, the BeltRunning variable is set to FALSE, and the ConveyorTimer is reset to 0.\nSimulated Rotation (Timed On/Off Cycle):\noWhile BeltRunning is TRUE, the ConveyorTimer (INT) counts up to RotationTime (INT, initialized to 5 seconds). This does not represent a true rotation but rather a timed on/off cycle of the motor to simulate movement.\noIf ConveyorTimer is less than RotationTime, the ConveyorMotor output remains TRUE.\noIf ConveyorTimer reaches RotationTime, the ConveyorTimer is reset to 0, and the cycle repeats. The ConveyorMotor remains TRUE during the entire cycle.\nInitial State: At the start of program execution, all variables should be initialized as follows: \noBeltRunning := FALSE;\noConveyorTimer := 0;\nInputs:StartButton (BOOL), StopButton (BOOL), EmergencyStop (BOOL)\nOutputs:ConveyorMotor (BOOL)\nInternal Variables:BeltRunning (BOOL), ConveyorTimer (INT), RotationTime (INT)\nFUNCTION_BLOCK SushiConveyorControl\nVAR_INPUT\n StartButton : BOOL; (* Input to start the conveyor *)\n StopButton : BOOL; (* Input to stop the conveyor *)\n EmergencyStop : BOOL; (* Input for emergency stop *)\nEND_VAR\nVAR_OUTPUT\n ConveyorMotor : BOOL; (* Output to control the conveyor motor *)\nEND_VAR\nVAR\n BeltRunning : BOOL; (* Status of the conveyor: Running or Stopped *)\n ConveyorTimer : INT; (* Timer counter for conveyor rotation *)\n RotationTime : INT := 5; (* Time for one rotation in seconds *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Emergency stop must have highest priority and stop everything",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.EmergencyStop",
          "1": "NOT instance.ConveyorMotor AND NOT instance.BeltRunning AND instance.ConveyorTimer = 0"
        },
        "entry_point": "SushiConveyorControl",
        "pattern_description": "If {instance.EmergencyStop} is true at the end of the PLC cycle, then {NOT instance.ConveyorMotor AND NOT instance.BeltRunning AND instance.ConveyorTimer = 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Start button should only work when system is stopped and no emergency",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StartButton AND NOT instance.BeltRunning AND NOT instance.EmergencyStop AND NOT instance.StopButton",
          "1": "instance.ConveyorMotor AND instance.BeltRunning"
        },
        "entry_point": "SushiConveyorControl",
        "pattern_description": "If {instance.StartButton AND NOT instance.BeltRunning AND NOT instance.EmergencyStop AND NOT instance.StopButton} is true at the end of the PLC cycle, then {instance.ConveyorMotor AND instance.BeltRunning} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Stop button should stop the system when it is running",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.StopButton AND instance.BeltRunning AND NOT instance.EmergencyStop",
          "1": "NOT instance.ConveyorMotor AND NOT instance.BeltRunning AND instance.ConveyorTimer = 0"
        },
        "entry_point": "SushiConveyorControl",
        "pattern_description": "If {instance.StopButton AND instance.BeltRunning AND NOT instance.EmergencyStop} is true at the end of the PLC cycle, then {NOT instance.ConveyorMotor AND NOT instance.BeltRunning AND instance.ConveyorTimer = 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Timer should only increment when belt is running",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "NOT instance.BeltRunning",
          "1": "instance.ConveyorTimer = 0"
        },
        "entry_point": "SushiConveyorControl",
        "pattern_description": "If {NOT instance.BeltRunning} is true at the end of the PLC cycle, then {instance.ConveyorTimer = 0} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Timer should stay within rotation time limits",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.ConveyorTimer >= 0 AND instance.ConveyorTimer <= instance.RotationTime"
        },
        "entry_point": "SushiConveyorControl",
        "pattern_description": "{instance.ConveyorTimer >= 0 AND instance.ConveyorTimer <= instance.RotationTime} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Motor and belt status must be consistent",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.BeltRunning",
          "1": "instance.ConveyorMotor"
        },
        "entry_point": "SushiConveyorControl",
        "pattern_description": "If {instance.BeltRunning} is true at the end of the PLC cycle, then {instance.ConveyorMotor} should always be true at the end of the same cycle."
      }
    }
  ],
  "id": "v2-M-69"
}
{
  "instruction": "Develop a PLC function block in ST for an AGV task scheduling system that:\n 1. Manages a queue of material handling requests (up to 10 tasks)\n - Maintains a FIFO (First-In-First-Out) queue for material handling requests\n - Ensures atomic and consistent queue updates\n \n 2. Controls the status of three AGVs\n - Manages the operational status (ready/working) of three AGVs\n - Tracks the position of each AGV in real-time\n - Automatically resets AGV status upon task completion\n \n 3. Implements a priority-based task assignment strategy\n - Assigns tasks based on priority (AGV1 > AGV2 > AGV3)\n - Ensures that the same task is not assigned to multiple AGVs simultaneously\n - Only assigns tasks to AGVs that are in the ready state\n \n 4. Enforces safety constraints\n - Ensures AGV positions are always non-negative\n - Properly releases AGV resources after task completion\n - Ensures the system can reach and maintain an idle state\n \n 5. Monitors and synchronizes states\n - Monitors the status of the material request queue\n - Tracks the working status of all AGVs\n - Ensures the correctness and reliability of state transitions\n \n 6. Implements error handling mechanisms\n - Handles invalid material requests\n - Prevents queue overflow\n - Ensures the safety of AGV state transitions\nFUNCTION_BLOCK AGVControlSystem\nVAR_INPUT\n MaterialRequest : INT; (* 新的物料请求 *)\nEND_VAR\nVAR_OUTPUT\n AGV1_Ready : BOOL := TRUE; (* AGV 1 就绪状态 *)\n AGV2_Ready : BOOL := TRUE; (* AGV 2 就绪状态 *)\n AGV3_Ready : BOOL := TRUE; (* AGV 3 就绪状态 *)\nEND_VAR\nVAR\n MaterialQueue : ARRAY[1..10] OF INT; (* 物料处理请求队列 *)\n AGVPosition : ARRAY[1..3] OF INT; (* AGV位置数组 *)\n i : INT; (* 循环计数器 *)\nEND_VAR\nEND_FUNCTION_BLOCK",
  "properties_to_be_validated": [
    {
      "property_description": "Multiple AGVs cannot be assigned to the same task",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-forbidden",
        "pattern_params": {
          "1": "(instance.AGVPosition[1] <> 0 AND instance.AGVPosition[2] <> 0 AND instance.AGVPosition[1] = instance.AGVPosition[2]) OR (instance.AGVPosition[1] <> 0 AND instance.AGVPosition[3] <> 0 AND instance.AGVPosition[1] = instance.AGVPosition[3]) OR (instance.AGVPosition[2] <> 0 AND instance.AGVPosition[3] <> 0 AND instance.AGVPosition[2] = instance.AGVPosition[3])"
        },
        "pattern_description": "{(instance.AGVPosition[1] <> 0 AND instance.AGVPosition[2] <> 0 AND instance.AGVPosition[1] = instance.AGVPosition[2]) OR (instance.AGVPosition[1] <> 0 AND instance.AGVPosition[3] <> 0 AND instance.AGVPosition[1] = instance.AGVPosition[3]) OR (instance.AGVPosition[2] <> 0 AND instance.AGVPosition[3] <> 0 AND instance.AGVPosition[2] = instance.AGVPosition[3])} is impossible at the end of the PLC cycle."
      }
    },
    {
      "property_description": "Available AGV must be assigned to task when queue is not empty",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.MaterialQueue[1] <> 0 AND instance.AGV1_Ready = TRUE",
          "1": "instance.AGVPosition[1] = instance.MaterialQueue[1]"
        },
        "pattern_description": "If {instance.MaterialQueue[1] <> 0 AND instance.AGV1_Ready = TRUE} is true at the end of the PLC cycle, then {instance.AGVPosition[1] = instance.MaterialQueue[1]} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "Queue must advance after task assignment",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-statechange-duringcycle",
        "pattern_params": {
          "0": "instance.MaterialQueue[1] <> 0 AND (NOT instance.AGV1_Ready OR NOT instance.AGV2_Ready OR NOT instance.AGV3_Ready)",
          "1": "instance.MaterialQueue[1] = instance.MaterialQueue[2]"
        },
        "pattern_description": "If {instance.MaterialQueue[1] <> 0 AND (NOT instance.AGV1_Ready OR NOT instance.AGV2_Ready OR NOT instance.AGV3_Ready)} is true at the beginning of the PLC cycle, then {instance.MaterialQueue[1] = instance.MaterialQueue[2]} is always true at the end of the same cycle."
      }
    },
    {
      "property_description": "AGV must be marked ready when task is completed",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-implication",
        "pattern_params": {
          "0": "instance.AGVPosition[1] = 0",
          "1": "instance.AGV1_Ready = TRUE"
        },
        "pattern_description": "If {instance.AGVPosition[1] = 0} is true at the end of the PLC cycle, then {instance.AGV1_Ready = TRUE} should always be true at the end of the same cycle."
      }
    },
    {
      "property_description": "All AGV positions must be non-negative",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "instance.AGVPosition[1] >= 0 AND instance.AGVPosition[2] >= 0 AND instance.AGVPosition[3] >= 0"
        },
        "pattern_description": "{instance.AGVPosition[1] >= 0 AND instance.AGVPosition[2] >= 0 AND instance.AGVPosition[3] >= 0} is always true at the end of the PLC cycle."
      }
    },
    {
      "property_description": "System must be able to reach and maintain idle state",
      "property": {
        "job_req": "pattern",
        "pattern_id": "pattern-invariant",
        "pattern_params": {
          "1": "NOT (instance.MaterialQueue[1] = 0 AND instance.AGV1_Ready = TRUE AND instance.AGV2_Ready = TRUE AND instance.AGV3_Ready = TRUE) OR (instance.AGVPosition[1] = 0 AND instance.AGVPosition[2] = 0 AND instance.AGVPosition[3] = 0)"
        },
        "pattern_description": "{NOT (instance.MaterialQueue[1] = 0 AND instance.AGV1_Ready = TRUE AND instance.AGV2_Ready = TRUE AND instance.AGV3_Ready = TRUE) OR (instance.AGVPosition[1] = 0 AND instance.AGVPosition[2] = 0 AND instance.AGVPosition[3] = 0)} is always true at the end of the PLC cycle."
      }
    }
  ],
  "id": "v2-M-70"
}